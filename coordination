#!/usr/bin/env bash
# coordination â€” multi-agent coordination for lean-zip
#
# All subcommands use `gh` CLI. Reads session UUID from $LEAN_ZIP_SESSION_ID
# (exported by ./go). Reads branch from git.
#
# Usage:
#   coordination orient           â€” list open plans (claimed/unclaimed), PRs, issues needing attention
#   coordination plan "title"     â€” create GitHub issue with agent-plan label (body from stdin)
#   coordination create-pr N      â€” push branch, create PR closing issue #N, enable auto-merge
#   coordination claim-fix N      â€” comment on failing PR #N claiming fix (30min cooldown)
#   coordination close-pr N "reason" â€” comment reason and close PR #N
#   coordination list-unclaimed   â€” list unclaimed agent-plan issues (FIFO order)
#   coordination queue-depth      â€” count of unclaimed agent-plan issues
#   coordination claim N          â€” claim an issue for this session (label + comment)
#   coordination skip N "reason"  â€” mark a claimed issue as skipped (stale/blocked)
#   coordination check-blocked    â€” unblock issues whose dependencies are all closed
#   coordination lock-planner    â€” acquire advisory planner lock (10min TTL)
#   coordination unlock-planner  â€” release planner lock early

set -euo pipefail

REPO="kim-em/lean-zip"
SESSION_ID="${LEAN_ZIP_SESSION_ID:-unknown}"
BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo detached)"
PLANNER_LOCK_ISSUE=8    # pinned sentinel issue for planner lock
PLANNER_LOCK_TTL=600    # lock expires after 10 minutes (seconds)

die() { echo "error: $*" >&2; exit 1; }

# Verify gh CLI is authenticated
gh auth status --hostname github.com >/dev/null 2>&1 || \
    die "gh CLI not authenticated â€” run 'gh auth login' first"

# Helper: get unclaimed issues as JSON array
_unclaimed_issues() {
    gh issue list --repo "$REPO" --label agent-plan --state open --limit 50 \
        --json number,title,labels,createdAt \
        --jq '[.[] | select(.labels | all(.name != "claimed") and all(.name != "skip") and all(.name != "blocked"))] |
              sort_by(.createdAt)'
}

# --- orient ---
cmd_orient() {
    echo "=== Unclaimed work items ==="
    _unclaimed_issues | jq -r '.[] | "#\(.number) \(.title) (\(.createdAt[:16]))"'

    echo ""
    echo "=== Claimed work items ==="
    gh issue list --repo "$REPO" --label agent-plan --label claimed --state open --limit 20 \
        --json number,title,createdAt \
        --template '{{range .}}#{{.number}} {{.title}} ({{timeago .createdAt}}){{"\n"}}{{end}}'

    echo ""
    echo "=== Open pull requests ==="
    gh pr list --repo "$REPO" --state open --limit 20 \
        --json number,title,headRefName,statusCheckRollup,labels \
        --template '{{range .}}#{{.number}} [{{.headRefName}}] {{.title}}{{range .labels}} ({{.name}}){{end}}{{range .statusCheckRollup}}{{if eq .conclusion "FAILURE"}} âœ—CI{{end}}{{end}}{{"\n"}}{{end}}'

    echo ""
    echo "=== PRs needing attention (failing CI, merge-conflict, or dirty) ==="
    gh pr list --repo "$REPO" --state open --limit 20 \
        --json number,title,labels,mergeable,statusCheckRollup \
        --jq '[.[] | select(
            (.labels | any(.name == "merge-conflict")) or
            (.mergeable == "CONFLICTING") or
            (.statusCheckRollup | any(.conclusion == "FAILURE"))
        )] | .[] | "#\(.number) \(.title)\(if .mergeable == "CONFLICTING" then " [CONFLICTS]" else "" end)\(if (.statusCheckRollup | any(.conclusion == "FAILURE")) then " [CI FAILED]" else "" end)"'
}

# --- plan ---
cmd_plan() {
    local title="${1:?usage: coordination plan \"title\"}"

    # Fetch all open agent-plan issues with full bodies for overlap detection
    local existing_json
    existing_json="$(gh issue list --repo "$REPO" --label agent-plan --state open --limit 50 \
        --json number,title,body)"

    # Warn if any existing issue title shares significant keywords with the new title
    local existing_titles
    existing_titles="$(echo "$existing_json" | jq -r '.[].title')"
    if [[ -n "$existing_titles" ]]; then
        # Extract key words (>4 chars) from the new title and check overlap
        local keywords
        keywords="$(echo "$title" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alpha:]' '\n' | \
            awk 'length > 4' | sort -u)"
        local overlap_found=false
        while IFS= read -r existing_title; do
            local existing_lower
            existing_lower="$(echo "$existing_title" | tr '[:upper:]' '[:lower:]')"
            local match_count=0
            local total_keywords=0
            while IFS= read -r kw; do
                [[ -z "$kw" ]] && continue
                total_keywords=$((total_keywords + 1))
                if echo "$existing_lower" | grep -qi "$kw"; then
                    match_count=$((match_count + 1))
                fi
            done <<< "$keywords"
            if [[ "$total_keywords" -gt 0 && "$match_count" -ge 2 ]]; then
                if [[ "$overlap_found" == false ]]; then
                    echo "warning: potentially overlapping open issues found:"
                    overlap_found=true
                fi
                echo "  - $existing_title"
            fi
        done <<< "$existing_titles"
        if [[ "$overlap_found" == true ]]; then
            echo "Proceeding anyway..."
        fi
    fi

    local body
    body="$(cat)"

    # Check for depends-on lines before creating the issue
    local create_labels="agent-plan"
    local deps
    deps="$(echo "$body" | grep -oE 'depends-on: #[0-9]+' | grep -oE '[0-9]+' || true)"
    if [[ -n "$deps" ]]; then
        local has_open_dep=false
        while read -r dep_num; do
            [[ -z "$dep_num" ]] && continue
            local dep_state
            dep_state="$(gh issue view "$dep_num" --repo "$REPO" --json state --jq .state 2>/dev/null || echo UNKNOWN)"
            if [[ "$dep_state" != "CLOSED" ]]; then
                has_open_dep=true
                break
            fi
        done <<< "$deps"
        if [[ "$has_open_dep" == true ]]; then
            create_labels="agent-plan,blocked"
        fi
    fi

    local issue_url
    issue_url="$(gh issue create --repo "$REPO" \
        --title "$title" \
        --label "$create_labels" \
        --body "$body")"

    # Extract issue number from the URL returned by gh issue create
    local issue_num
    issue_num="${issue_url##*/}"

    if [[ "$create_labels" == *"blocked"* ]]; then
        echo "Created issue #$issue_num: $title (blocked â€” depends on open issue(s))"
    else
        echo "Created issue #$issue_num: $title"
    fi

    if [[ -n "$issue_num" ]]; then
        gh issue comment "$issue_num" --repo "$REPO" \
            --body "Session: \`$SESSION_ID\` Branch: \`$BRANCH\`"
    fi
}

# --- create-pr ---
cmd_create_pr() {
    local issue_num="${1:?usage: coordination create-pr N}"

    # Guard: refuse to create PR from master or detached HEAD
    if [[ "$BRANCH" == "master" || "$BRANCH" == "main" || "$BRANCH" == "detached" ]]; then
        die "cannot create PR from branch '$BRANCH' â€” use an agent/* branch"
    fi

    # Push branch
    git push -u origin "$BRANCH"

    # Check if PR already exists for this branch
    local existing_pr
    existing_pr="$(gh pr list --repo "$REPO" --head "$BRANCH" --json number --jq '.[0].number // empty')"
    if [[ -n "$existing_pr" ]]; then
        echo "PR #$existing_pr already exists for branch $BRANCH. Enabling auto-merge."
        gh pr merge "$existing_pr" --repo "$REPO" --auto --squash || \
            echo "warning: auto-merge not available (branch protection may not be set up)"
        return 0
    fi

    # Create PR
    gh pr create --repo "$REPO" \
        --head "$BRANCH" \
        --title "$(gh issue view "$issue_num" --repo "$REPO" --json title --jq .title)" \
        --body "$(cat <<EOF
Closes #$issue_num

Session: \`$SESSION_ID\`

$(git log origin/master..HEAD --oneline)

ðŸ¤– Prepared with Claude Code
EOF
)"

    # Enable auto-merge
    local pr_num
    pr_num="$(gh pr list --repo "$REPO" --head "$BRANCH" --json number --jq '.[0].number')"
    if [[ -n "$pr_num" ]]; then
        gh pr merge "$pr_num" --repo "$REPO" --auto --squash || \
            echo "warning: auto-merge not available (branch protection may not be set up)"
    fi
}

# --- claim-fix ---
# NOTE: claim-fix is best-effort advisory, not strict mutual exclusion.
# Two agents may both claim the same PR in a narrow race window.
# Branch protection serializes the actual merges, so worst case is
# duplicate work, not corruption.
cmd_claim_fix() {
    local pr_num="${1:?usage: coordination claim-fix N}"

    # Check for recent claims (last 30 minutes)
    local recent_claim
    recent_claim="$(gh api --paginate "repos/$REPO/issues/$pr_num/comments" \
        --jq '[.[] | select(.body | test("Session .* attempting fix")) |
               select(.created_at > (now - 1800 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
               length')"

    if [[ "$recent_claim" -gt 0 ]]; then
        echo "Another session claimed this PR in the last 30 minutes. Skipping."
        return 1
    fi

    gh issue comment "$pr_num" --repo "$REPO" \
        --body "Session \`$SESSION_ID\` attempting fix on branch \`$BRANCH\`"
}

# --- close-pr ---
cmd_close_pr() {
    local pr_num="${1:?usage: coordination close-pr N \"reason\"}"
    local reason="${2:?usage: coordination close-pr N \"reason\"}"

    gh pr close "$pr_num" --repo "$REPO" \
        --comment "$reason (Session: \`$SESSION_ID\`)"
}

# --- list-unclaimed ---
cmd_list_unclaimed() {
    _unclaimed_issues | jq -r '.[] | "#\(.number) \(.title) (\(.createdAt[:16]))"'
}

# --- queue-depth ---
cmd_queue_depth() {
    _unclaimed_issues | jq 'length'
}

# --- claim ---
# Claim an issue for this session. Uses label + comment.
# Returns 0 on success, 1 if already claimed or race detected.
cmd_claim() {
    local issue_num="${1:?usage: coordination claim N}"

    # Check if already claimed
    local labels
    labels="$(gh issue view "$issue_num" --repo "$REPO" --json labels --jq '[.labels[].name] | join(",")')"
    if echo "$labels" | grep -qw 'claimed'; then
        echo "Issue #$issue_num is already claimed. Skipping."
        return 1
    fi
    if echo "$labels" | grep -qw 'skip'; then
        echo "Issue #$issue_num was skipped. Skipping."
        return 1
    fi
    if echo "$labels" | grep -qw 'blocked'; then
        echo "Issue #$issue_num is blocked by dependencies. Skipping."
        return 1
    fi

    # Claim: add label + comment
    gh issue edit "$issue_num" --repo "$REPO" --add-label claimed
    gh issue comment "$issue_num" --repo "$REPO" \
        --body "Claimed by session \`$SESSION_ID\` on branch \`$BRANCH\`"

    # Race detection: wait briefly, then check for multiple recent claims
    sleep 2
    local recent_claims
    recent_claims="$(gh api --paginate "repos/$REPO/issues/$issue_num/comments" \
        --jq '[.[] | select(.body | test("Claimed by session")) |
               select(.created_at > (now - 60 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
               length')"

    if [[ "$recent_claims" -gt 1 ]]; then
        # Race detected â€” lowest UUID wins
        local winner
        winner="$(gh api --paginate "repos/$REPO/issues/$issue_num/comments" \
            --jq '[.[] | select(.body | test("Claimed by session")) |
                   select(.created_at > (now - 60 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
                   sort_by(.body) | .[0].body |
                   match("session `([^`]+)`") | .captures[0].string')"

        if [[ "$winner" != "$SESSION_ID" ]]; then
            echo "Race detected on #$issue_num â€” session $winner won. Backing off."
            # Do NOT remove the 'claimed' label â€” the winner needs it
            return 1
        fi
        echo "Race detected on #$issue_num â€” this session won."
    fi

    echo "Claimed issue #$issue_num"
}

# --- skip ---
# Mark a claimed issue as skipped (stale or blocked).
cmd_skip() {
    local issue_num="${1:?usage: coordination skip N \"reason\"}"
    local reason="${2:?usage: coordination skip N \"reason\"}"

    gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed --add-label skip
    gh issue comment "$issue_num" --repo "$REPO" \
        --body "Skipped by session \`$SESSION_ID\`: $reason"
    echo "Skipped issue #$issue_num: $reason"
}

# --- lock-planner ---
# Advisory lock to prevent concurrent planner sessions.
# Uses 'eyes' reactions on a pinned sentinel issue with a TTL.
# Returns 0 if lock acquired, 1 if another planner is active.
cmd_lock_planner() {
    local cutoff
    cutoff="$(date -u -v-${PLANNER_LOCK_TTL}S '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || \
              date -u -d "$PLANNER_LOCK_TTL seconds ago" '+%Y-%m-%dT%H:%M:%SZ')"

    # Get all 'eyes' reactions on the sentinel issue
    local reactions
    reactions="$(gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/reactions" \
        --jq "[.[] | select(.content == \"eyes\")]")"

    # Check for unexpired reactions (within TTL)
    local active
    active="$(echo "$reactions" | jq "[.[] | select(.created_at > \"$cutoff\")] | length")"

    # Clean up expired reactions
    echo "$reactions" | jq -r ".[] | select(.created_at <= \"$cutoff\") | .id" | \
    while read -r reaction_id; do
        [[ -z "$reaction_id" ]] && continue
        gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/reactions/$reaction_id" -X DELETE 2>/dev/null || true
    done

    if [[ "$active" -gt 0 ]]; then
        echo "Another planner is active (lock held). Skipping."
        return 1
    fi

    # Acquire lock: add eyes reaction
    gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/reactions" -f content=eyes --silent
    echo "Planner lock acquired"
}

# --- unlock-planner ---
# Release the planner lock by removing our eyes reaction.
cmd_unlock_planner() {
    # Find and delete all eyes reactions (there should be at most one from us)
    gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/reactions" \
        --jq '.[] | select(.content == "eyes") | .id' | \
    while read -r reaction_id; do
        [[ -z "$reaction_id" ]] && continue
        gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/reactions/$reaction_id" -X DELETE 2>/dev/null || true
    done
    echo "Planner lock released"
}

# --- check-blocked ---
# Scan blocked issues and unblock those whose dependencies are all closed.
cmd_check_blocked() {
    local issues
    issues="$(gh issue list --repo "$REPO" --label blocked --state open --limit 50 \
        --json number,body)"

    echo "$issues" | jq -c '.[]' | \
    while read -r issue_json; do
        local num body
        num="$(echo "$issue_json" | jq -r '.number')"
        body="$(echo "$issue_json" | jq -r '.body')"

        local deps
        deps="$(echo "$body" | grep -oE 'depends-on: #[0-9]+' | grep -oE '[0-9]+' || true)"
        [[ -z "$deps" ]] && continue

        local all_closed=true
        while read -r dep_num; do
            [[ -z "$dep_num" ]] && continue
            local dep_state
            dep_state="$(gh issue view "$dep_num" --repo "$REPO" --json state --jq .state 2>/dev/null || echo UNKNOWN)"
            if [[ "$dep_state" != "CLOSED" ]]; then
                all_closed=false
                break
            fi
        done <<< "$deps"

        if [[ "$all_closed" == true ]]; then
            gh issue edit "$num" --repo "$REPO" --remove-label blocked
            echo "Unblocked issue #$num (all dependencies resolved)"
        fi
    done
}

# --- dispatch ---
case "${1:-}" in
    orient)          cmd_orient ;;
    plan)            shift; cmd_plan "$@" ;;
    create-pr)       shift; cmd_create_pr "$@" ;;
    claim-fix)       shift; cmd_claim_fix "$@" ;;
    close-pr)        shift; cmd_close_pr "$@" ;;
    list-unclaimed)  cmd_list_unclaimed ;;
    queue-depth)     cmd_queue_depth ;;
    claim)           shift; cmd_claim "$@" ;;
    skip)            shift; cmd_skip "$@" ;;
    check-blocked)   cmd_check_blocked ;;
    lock-planner)    cmd_lock_planner ;;
    unlock-planner)  cmd_unlock_planner ;;
    *)               die "unknown command: ${1:-}
Usage: coordination {orient|plan|create-pr|claim-fix|close-pr|list-unclaimed|queue-depth|claim|skip|check-blocked|lock-planner|unlock-planner}" ;;
esac
