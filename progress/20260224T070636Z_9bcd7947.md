# Progress: Prove decode_go_complete and huffTree_decode_complete

**Date**: 2026-02-24T07:06Z
**Session**: 9bcd7947 (worker)
**Issue**: #160

## Accomplished

Both deliverables completed:

1. **`decode_go_complete`** in `HuffmanCorrect.lean` — proved that if a
   `HuffTree` has a leaf at path `cw` and the `BitReader`'s bits start with
   `cw ++ rest`, then the native `decode.go` succeeds. Proof by induction on
   `TreeHasLeaf`, using `readBit_complete` at each step. Added import for
   `BitstreamComplete`.

2. **`huffTree_decode_complete`** in `DecodeCorrect.lean` — proved that if
   the spec's `Huffman.Spec.decode` succeeds, then the native `HuffTree.decode`
   also succeeds with the same symbol. Uses `decode_some_mem` → `fromLengths_hasLeaf`
   → `decode_go_complete`.

## Decisions

- **Changed `maxBits < 32` to `maxBits ≤ 20`** in `huffTree_decode_complete`.
  The native `decode.go` has a depth-20 guard (`if n > 20 then error`), making
  the theorem unprovable for `maxBits > 20`. All callers use `maxBits = 15`,
  so the weakened bound is non-breaking. This is a genuine bug fix in the spec —
  the previous statement was false.

## Sorry count

- Before: 8
- After: 7 (removed 1 sorry in DecodeCorrect.lean)
- Remaining in DecodeCorrect.lean: `decodeHuffman_complete` (1 sorry)
