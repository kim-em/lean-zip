# Progress: Prove emitTokens_spec (Issue #95)

**Date**: 2026-02-23 15:07 UTC
**Session**: 018fbf8e (worker, implementation)
**Issue**: #95 — Prove emitTokens_spec — native ↔ spec fixed Huffman encode
**Branch**: agent/018fbf8e
**Starting commit**: 2ea77be9

## What was accomplished

Proved `emitTokens_spec`: the native `emitTokens` function (writing
Huffman-coded bits via `BitWriter`) produces the same bit sequence as
the spec-level `encodeSymbols` function for fixed Huffman tables.

### Key proof infrastructure built

1. **Table equality bridges**: `fixedLitLengths_eq` and `fixedDistLengths_eq`
   proving native `Array UInt8` tables match spec `List Nat` tables.
   Required `maxRecDepth 4096` and `maxHeartbeats 4000000` for the 288-element
   literal table.

2. **ValidLengths bridges**: `fixedLitLengths_validLengths` and
   `fixedDistLengths_validLengths` transport the spec validity proof to
   the native table representation.

3. **Canonical code agreement**: `fixedLitCodes_agree` and `fixedDistCodes_agree`
   prove that `codeFor` on the spec table produces the same codeword as
   `natToBits` on the `canonicalCodes` entry. Used `congrArg` to avoid
   max recursion when rewriting through 288-element list equality.

4. **encodeSymbol bridges**: `encodeSymbol_litTable_eq` and
   `encodeSymbol_distTable_eq` connect the `encodeSymbol` result (from
   flipped `allCodes` table) to the `fixedLitCodes`/`fixedDistCodes` entries.

5. **Main inductive proof** (`emitTokens_spec_go`): Strong induction on
   `tokens.size - i` with cases for literal and reference tokens.
   - Literal case: direct `writeHuffCode` correspondence
   - Reference case: 4-step BitWriter chain (writeHuffCode + writeBits for
     length, writeHuffCode + writeBits for distance), UInt32 faithfulness
     for extra values, and IH application

### Key proof patterns discovered

- **`array_get!Internal_eq`**: After `unfold emitTokens`, Lean shows
  `Array.get!Internal` internally. Bridge with `a.get!Internal i = a[i]! := rfl`.
- **`congrArg` for large list rewrites**: `rw [← fixedLitLengths_eq] at h`
  hits max recursion on 288-element lists. Use
  `congrArg (Huffman.Spec.codeFor · 15 s) fixedLitLengths_eq` instead.
- **Explicit BitWriter args**: `BitWriter.writeHuffCode_wf bw _ _ hwf hlen`
  fails because `code` can't be inferred from wildcards. Must provide
  explicit `code` and `len` arguments.
- **`Nat.pow_le_pow_right` for power bounds**: `omega` can't reason about
  `2^n`. Use `Nat.lt_of_lt_of_le h (Nat.pow_le_pow_right _ _)` to
  chain `x < 2^n ≤ 2^32`.
- **`let` in tactic mode + `rfl`**: `let lcode := expr` preserves
  definitional equality, so `rfl` closes goals with `lcode` vs `expr`.

## Decisions made

- Left `findLengthCode_agree` and `findDistCode_agree` as sorry — these
  require proving native `findTableCode` linear search agrees with spec
  linear search. The tables are identical between native/spec, just different
  types. Straightforward but mechanical.
- Used `let` bindings in the reference case to name intermediate BitWriter
  states, avoiding wildcard inference failures.

## What remains

- `findLengthCode_agree` (sorry) — table correspondence for length codes
- `findDistCode_agree` (sorry) — table correspondence for distance codes
- `deflateFixed_spec` (sorry) — end-to-end fixed block encoding
- `inflate_complete`, `inflate_deflateFixed`, `inflate_deflateLazy` (sorry)

## Sorry count

- Start: 11
- End: 12 (proved 1 sorry in `emitTokens_spec`, added 2 bridge stubs)
