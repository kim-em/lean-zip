# Progress: Prove decodeDynamicTrees_complete

**Date**: 2026-02-24T09:53Z
**Session**: worker (implementation)
**Issue**: #136

## Accomplished

1. **Proved `decodeDynamicTrees_complete`** — the completeness direction for
   dynamic Huffman tree decode. If the spec `decodeDynamicTables` succeeds on
   a bit list, the native `decodeDynamicTrees` also succeeds with
   corresponding results. Removed 1 sorry from InflateCorrect.lean.

2. **Fixed fuel bug in native `decodeDynamicTrees`** — the native code called
   `decodeCLSymbols` with `fuel = totalCodes`, but `totalCodes + 1` is needed
   to handle the worst case (all individual code length symbols). The spec
   already used `totalCodes + 1`. Updated the native and the correctness proof
   in DynamicTreesCorrect.lean (removed now-unnecessary `fuel_independent`
   bump).

3. **Added Kraft validity guards to spec `decodeDynamicTables`** (from prior
   commit 137fcb7) — the spec didn't check `ValidLengths` (Kraft inequality)
   but the native `fromLengths` does. Added three `guard (ValidLengths ...)`
   checks. Updated `encodeDynamicTrees_decodeDynamicTables` with matching
   hypotheses.

4. **Proved `fromLengths_complete`** helper — if `ValidLengths` holds,
   `fromLengths` succeeds. Reverse of `fromLengths_valid`.

5. **Changed visibility** of `readCLCodeLengths_complete`,
   `decodeCLSymbols_complete`, `readCLCodeLengths_size`, and
   `decodeCLSymbols_size` from `private` to `protected` for cross-file access.

## Key Proof Patterns

- **Option do-notation guard extraction**: After `unfold spec at hspec`,
  guards create `match guard (...), fun x => ...` expressions. Use
  `by_cases h : condition` — in the positive branch, the guard reduces via
  `simp [guard, h] at hspec`; in the negative branch,
  `simp [guard, h] at hspec` derives contradiction.

- **UInt8 roundtrip identity**: `Nat.toUInt8 ∘ UInt8.toNat = id` via
  `unfold Nat.toUInt8 UInt8.ofNat UInt8.toNat; rw [BitVec.ofNat_toNat, BitVec.setWidth_eq]`

- **Array↔List roundtrip**: `a.toList.toArray = a` is `Array.toArray_toList`

- **Fuel mismatch between spec and native**: When spec uses fuel `n+1` but
  native uses fuel `n`, the completeness proof can't bridge downward.
  Fix the native to match the spec's fuel. Use `decodeCLSymbols_fuel_independent`
  only for the upward direction.

## Sorry Count

Before: 6 (2 InflateCorrect, 3 DeflateFixedCorrect, 1 DecodeCorrect)
After:  5 (1 InflateCorrect, 3 DeflateFixedCorrect, 1 DecodeCorrect)
Delta:  -1

## What Remains

- `inflateLoop_complete` (InflateCorrect.lean) — 1 sorry
- 3 sorries in DeflateFixedCorrect.lean — pre-existing
- 1 sorry in DecodeCorrect.lean — pre-existing
