# Progress: prove lz77GreedyIter_eq_lz77Greedy

- **Date**: 2026-02-25T11:13Z
- **Session type**: feature
- **Issue**: #294

## Accomplished

Proved `lz77GreedyIter_eq_lz77Greedy` in `Zip/Spec/DeflateFixedCorrect.lean`,
eliminating the last sorry in that file.

### Proof structure

The proof decomposes the equivalence between the iterative (Array-push) and
recursive (List-cons) LZ77 greedy matchers into five lemmas:

1. **`go_eq`**: Strong induction on `maxLen - i`. Both `where`-block `go`
   helpers are structurally identical but NOT definitionally equal (separate
   well-founded recursion fixpoints). Proved by unfolding both and matching
   branches.

2. **`countMatch_eq`**: Unfolds both `countMatch` definitions (which are just
   `go data p1 p2 0 maxLen`) and applies `go_eq`.

3. **`updateHashes_eq`**: Strong induction on `matchLen - j`. After
   unfolding, branches match exactly (no accumulator difference).

4. **`trailing_eq`**: Accumulator lemma: `trailing_iter data pos acc =
   acc ++ (trailing_rec data pos).toArray`. Uses `List.toArray_cons`,
   `Array.push_eq_append`, and `Array.append_assoc`.

5. **`mainLoop_eq`**: Accumulator lemma for the main loop. Uses
   `simp only [hash3_rfl, countMatch_eq, updateHashes_eq]` to normalize
   the iter helpers to their greedy counterparts before splitting branches.

### Key insight

`hash3` IS definitionally equal between the two `where` blocks (non-recursive),
but `go`, `countMatch`, and `updateHashes` are NOT (each has its own
well-founded recursion fixpoint). The `hash3` rfl-equality was used as a
`simp` lemma to normalize `lz77GreedyIter.hash3` â†’ `lz77Greedy.hash3`
inside unfolded `mainLoop` terms, enabling `split` to unify branches.

## Sorry count

- Before: 2 (1 in DeflateFixedCorrect.lean, 1 in GzipCorrect.lean)
- After: 1 (0 in DeflateFixedCorrect.lean, 1 in GzipCorrect.lean)
- Delta: -1
