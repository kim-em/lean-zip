# Progress: GzipCorrect BitReader invariant infrastructure

- **Date**: 2025-02-24 23:17 UTC (session 2 of 2)
- **Session type**: Worker (implementation)
- **Issue**: #238 — Prove gzip roundtrip: gzip_decompressSingle_compress
- **Branch**: `agent/ad0bf829`
- **Starting commit**: `6da1454`

## What was accomplished

Added combined BitReader invariant lemmas that track three properties
simultaneously through each operation:
1. `br'.data = br.data` (data preservation)
2. `br'.bitOff = 0 ∨ br'.pos < br'.data.size` (hpos invariant)
3. `br'.pos ≤ br'.data.size` (pos bound)

### Fully proved (6 lemmas)
- `readBit_inv`: readBit preserves all three invariants
- `readBits_go_inv`: readBits.go preserves invariants (induction on n)
- `readBits_inv`: readBits wrapper
- `decode_go_inv`: HuffTree.decode.go preserves invariants (tree induction)
- `decode_inv`: HuffTree.decode wrapper
- `readCLCodeLengths_inv`: readCLCodeLengths preserves invariants
  (strong induction via `suffices ∀ m ...` with `m = numCodeLen - i`)

### Sorry'd (7 proofs)
- `decodeStored_inv`: readBytes pos bound needs careful omega
- `decodeHuffman_go_inv`: deeply nested do-notation with guard matches
- `decodeCLSymbols_inv`: 5-branch fuel-based recursion
- `decodeDynamicTrees_inv`: simp can't match expanded form
- `inflateLoop_endPos_le`: block-type dispatch (btype 0/1/2/_) after
  readBits for bfinal+btype are proved
- `inflateRaw_endPos_le`: startPos ≤ data.size derivation
- `gzip_decompressSingle_compress`: full roundtrip (blocked on above)

### Key proof patterns discovered
- **Combined `_inv` lemma pattern**: Bundle data_eq + hpos + pos_le into
  one And3 return to reduce boilerplate. Chain data_eq with `.trans`.
- **`▸` vs `.trans` for data equality**: `▸` rewrites in the wrong
  direction for dependent types (changes goal from `br'.data.size` to
  `br.data.size`). Use `exact ⟨hd'.trans hd₁, hpos', hple'⟩` instead.
- **Strong induction for `readCLCodeLengths`**: `induction numCodeLen - i`
  loses the equation. Use `suffices ∀ m br clLengths i numCodeLen,
  m = numCodeLen - i → ...` to carry the decreasing measure explicitly.

### Signature change
- `inflateLoop_endPos_le` now takes an additional `hple : br.pos ≤ br.data.size`
  parameter. This is necessary because the recursive case needs both
  hpos and pos_le to propagate through readBits.

## Decisions made
- Sorry'd complex do-notation proofs rather than fighting with expanded
  forms. Each sorry'd lemma has a clear theorem statement that future
  sessions can prove independently.
- Changed `inflateLoop_endPos_le` signature to include `hple` —
  necessary for the proof to go through (hpos alone is insufficient
  for some branches).

## Sorry count
- Start: 4 (GzipCorrect: 2, ZlibCorrect: 2)
- End: 10 (GzipCorrect: 8, ZlibCorrect: 2)
- Net: +6 (all in new helper lemma infrastructure, not regressions)
- The original 2 sorry's in GzipCorrect (inflateLoop_endPos_le,
  gzip_decompressSingle_compress) now have partial proofs with sorry's
  deeper in the call chain, plus 5 new helper lemmas with sorry.

## What remains
- **Not completed**: Neither deliverable from #238 is fully proved
  - `inflateLoop_endPos_le` has sorry at block-type dispatch
  - `gzip_decompressSingle_compress` has sorry (blocked on above)
- **Needs new issue**: Prove the 5 sorry'd helper lemmas
  (decodeStored_inv, decodeHuffman_go_inv, decodeCLSymbols_inv,
  decodeDynamicTrees_inv, inflateRaw_endPos_le startPos bound)
