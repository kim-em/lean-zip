# Progress: Refactor lz77Greedy to explicit recursion

**Date**: 2026-02-23 09:41 UTC
**Session type**: Implementation (worker)
**Issue**: #58 — Refactor lz77Greedy to explicit recursion and prove loop properties

## What was accomplished

Refactored `lz77Greedy` from `Id.run do` with `while` loops to explicit
well-founded recursive functions, enabling formal proofs of loop properties.

### Deflate.lean changes
- Extracted `lz77Hash3`, `lz77Go`, `lz77CountMatch` as top-level definitions
  (previously private inside `lz77Greedy`)
- Proved `lz77Go_bounds` and `lz77CountMatch_le` bound theorems
- Rewrote `lz77Greedy` with explicit recursive `where` functions:
  `smallData`, `updateHashes`, `mainLoop`, `trailing`
- Added `have _h` in `mainLoop` body + `change` in `decreasing_by` for
  termination proof of reference case

### LZ77NativeCorrect.lean changes
- Updated `go_matches` → `lz77Go_matches` (unfolds `lz77Go` directly)
- Updated `countMatch_matches` → `lz77CountMatch_matches`
- Added backward-compatible aliases
- Proved `trailing_valid`, `smallData_valid`, `mainLoop_valid`,
  `lz77Greedy_valid` (ValidDecomp correctness)
- Proved `trailing_encodable`, `smallData_encodable`, `mainLoop_encodable`,
  `lz77Greedy_encodable` (DEFLATE encoding range bounds)
- Proved `lz77Greedy_resolves` (BB1: resolving tokens recovers original data)

## Key proof patterns discovered

- **`dsimp only []` before `split` on unfolded recursive functions**: After
  `unfold lz77Greedy.mainLoop`, the goal has nested `let` bindings. `split`
  cannot see `if` expressions inside let bindings. Use `dsimp only []` to
  zeta-reduce all let bindings, then `split` works freely.

- **Explicit arguments for `lz77CountMatch_le` in proofs**: When the first
  argument to `lz77CountMatch` is a complex expression like
  `hashTable[lz77Hash3 data pos hashSize]!`, the `_` placeholder cannot be
  inferred. Spell out the full expression explicitly.

- **`all_goals` pattern for `decreasing_by` with mixed difficulty**: When
  some decreasing goals need auxiliary `have` statements and others don't:
  ```lean
  decreasing_by
    all_goals simp_wf
    all_goals first
      | omega
      | (have := Nat.min_le_right 258 (data.size - pos); omega)
  ```
  This avoids needing to count bullets and handles goal reordering.

- **`Nat.sub_sub_self` for reference distance**: The `ValidDecomp.reference`
  constructor needs `data[pos + i]! = data[pos - dist + i]!` where
  `dist = pos - matchPos`. Since `pos - (pos - matchPos) = matchPos`
  (when `matchPos ≤ pos`), use `rw [Nat.sub_sub_self (by omega)]` to
  bridge the gap, then `.symm` on the countMatch result.

## Sorry count
- Before: 8 (6 in DeflateFixedCorrect.lean, 2 in LZ77NativeCorrect.lean)
- After: 6 (6 in DeflateFixedCorrect.lean, 0 in LZ77NativeCorrect.lean)
- Delta: -2
