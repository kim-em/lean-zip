# Progress: RLE encoding/decoding of DEFLATE code lengths

- **Date**: 2026-02-23T09:37Z
- **Session**: worker (issue #66)
- **Branch**: agent/18fedd5d

## What was accomplished

Implemented spec-level RLE encoding and decoding for DEFLATE dynamic block
code lengths (RFC 1951 section 3.2.7) with full proofs, no sorry.

### New definitions
- `CLEntry` type alias for `(clCode, extraValue)` pairs
- `countRun val xs`: count consecutive occurrences of `val` at front of `xs`
- `rlEncodeLengths lengths`: greedy RLE encoder using codes 16-18
- `rlDecodeLengths entries`: inverse decoder with accumulator for code 16

### Proven theorems
- `countRun_le_length`: run count bounded by list length
- `countRun_take`: first `countRun` elements are all the target value
- `take_countRun_eq_replicate`: generalization for any prefix within the run
- `rlDecodeLengths_rlEncodeLengths`: roundtrip correctness (decode . encode = id)
- `rlEncodeLengths_valid`: all output entries satisfy CL code constraints

### Key proof patterns discovered
- **`simp [f]` for selective unfolding**: When `unfold f` unfolds ALL occurrences
  (both LHS and RHS), use `simp [f]` instead. Lean's equation lemmas for `f`
  only match constructor-headed arguments, so abstract variables on the RHS
  don't get rewritten. This selectively unfolds only the LHS.
- **`Bool.false_eq_true, reduceIte` for stuck if-then-else**: After simplifying
  `(x == 0) = false`, goals contain `if false = true then ... else ...`.
  Adding `Bool.false_eq_true, reduceIte` to simp reduces these.
- **`guard, pure, bind` for do-notation guards**: `guard True` in Option
  do-blocks doesn't reduce without explicitly adding these to simp.
- **`<;>` vs `;` in termination proofs**: Use `all_goals simp_all [...] <;> omega`
  not `...; omega` â€” the latter fails when simp_all closes all goals (leaving
  nothing for omega), while `<;>` is vacuously successful on zero goals.
- **`simp only [List.mem_cons]` applies recursively**: When applied to
  `entry in a :: b :: rest`, it produces `entry = a \/ entry = b \/ entry in rest`
  in one step, making a second `simp only [List.mem_cons]` unnecessary.

## Sorry count
- Before: 2 (in LZ77NativeCorrect.lean)
- After: 2 (unchanged)

## Files changed
- `Zip/Spec/DeflateEncode.lean`: +295 lines (from 651 to 946 lines)
