# Progress: Partial progress on deflateFixed_spec helpers

- **Date**: 2026-02-24T05:03Z
- **Session**: 9bcd7947 (worker, implementation)
- **Issue**: #115 — Prove deflateFixed_spec — bitstream correspondence for Level 1 compressor
- **Branch**: agent/9bcd7947
- **Starting commit**: 63921b4
- **Sorry count**: 13 → 13 (no net change — helpers proved without sorry, main theorem still has sorry)

## Accomplished

### Helper lemmas (committed)
1. **`encodeSymbols_append_singleton`**: Forward direction — if `encodeSymbols ll dl xs = some bits₁` and `encodeLitLen ll dl s = some bits₂`, then `encodeSymbols ll dl (xs ++ [s]) = some (bits₁ ++ bits₂)`. Proved by induction on `xs`.

2. **`encodeSymbols_append_singleton_inv`**: Inverse direction — if `encodeSymbols ll dl (xs ++ [s]) = some bits`, then both parts succeed and `bits = bits₁ ++ bits₂`. Also by induction.

3. **`encodeLitLen_ref_decompose`**: Decomposes `encodeLitLen` success for `.reference len dist` into existence of spec-level `findLengthCode`, `findDistCode`, and `encodeSymbol` results with their properties. Required `set_option maxRecDepth 4096` for the nested existential construction.

4. **`emitTokens_wf_go`**: Proves `emitTokens bw tokens i` preserves `BitWriter.wf`. Mirrors `emitTokens_spec_go` structure, using `encodeLitLen_ref_decompose` for the reference case and chaining `writeHuffCode_wf`/`writeBits_wf` through the BitWriter operations.

5. **`litCode_len_from_enc`**: Extracts `fixedLitCodes[b.toNat]!.2.toNat ≤ 15` from `encodeSymbol` success.

### deflateFixed_spec structure (partial)
- Established `encodeFixed` succeeds with `some ([true, true, false] ++ fullBits)`
- Proved padding is always empty: `bytesToBits` length is divisible by 8
- Decomposed `fullBits` into `tokenBits ++ eobBits` via `encodeSymbols_append_singleton_inv`
- Remaining sorry: `bytesToBits (deflateFixed data) = [true, true, false] ++ tokenBits ++ eobBits`

### Other changes
- Changed `deflateFixedBlock` from `private` to `protected` in `Zip/Native/Deflate.lean` (committed in first commit)

## Decisions
- Used `match` instead of `cases` in `encodeLitLen_ref_decompose` to preserve original hypothesis names (avoids `cases` substituting into goal type)
- Fully qualified all `Deflate.Spec.*` names in `encodeLitLen_ref_decompose` to avoid namespace resolution picking up native versions (which return `UInt32` instead of `Nat`)
- Used `Prod.ext_iff.mp` for nested tuple decomposition (instead of `congrArg Prod.fst/snd` which doesn't work on right-associated nested Prods)

## Not completed
- **`deflateFixed_spec` body**: The remaining sorry requires chaining BitWriter correspondence lemmas (`flush_toBits`, `writeHuffCode_toBits`, `emitTokens_spec`, `writeBits_toBits`) to connect the native imperative BitWriter chain to the spec-level bit concatenation. Also needs to show `writeBitsLSB 1 1 ++ writeBitsLSB 2 1 = [true, true, false]` and handle the `data.size == 0` case split.
- **Sorry count reduction**: No net change because the helper lemmas are sorry-free but the main theorem still has its sorry.

## Context
Session hit context compaction. Wrapped up with partial progress per protocol.
