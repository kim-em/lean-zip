# Progress: Prove CL-length recovery helpers

**Date**: 2026-02-24T04:01 UTC
**Session type**: implementation (worker)
**Issue**: #124

## Accomplished

Proved both CL-length recovery helper lemmas in
`Zip/Spec/DeflateEncodeDynamic.lean`:

### 1. `computeHCLEN_trailing_zero` (was line 756)
After `computeHCLEN` determines how many CL code lengths to transmit,
positions not transmitted (indices >= computeHCLEN) all have value 0 in
the permuted order.

**Key technique**: Used `List.IsPrefix.getElem` from `takeWhile_prefix`
to connect the trailing-zero suffix of the reversed permuted list to
individual element values. `List.all_takeWhile` + `List.all_eq_true`
extracts the predicate satisfaction. Used `change` to unify let-bound
variable references in omega hypotheses.

### 2. `readCLLengths_recovers_clLens` (was line 771)
The foldl-set over `clPermutation.take n` on `replicate 19 0` recovers
the original CL lengths list when trailing positions have value 0.

**Key technique**: Proved by `List.ext_getElem`. Required three helper
lemmas:
- `foldl_set_length`: foldl-set preserves list length
- `foldl_set_getElem_not_mem`: positions not in the fold list retain
  initial values
- `foldl_set_getElem_mem`: positions in the fold list (with nodup) get
  the specified value
- `clPermutation_contains_all`: every p < 19 appears in clPermutation

## Proof patterns discovered

- **`let` bindings vs `omega`**: When `omega` needs to connect variables
  from different scopes (e.g. `hj` from computeHCLEN vs local `tw`),
  use `change` to rewrite the hypothesis to use the let-bound variable
  names. `omega` treats syntactically distinct expressions as different
  variables even when definitionally equal.

- **`List.IsPrefix.getElem`**: For `h : xs <+: ys` and `hi : i < xs.length`,
  gives `xs[i] = ys[i]`. Useful for connecting `takeWhile` elements back
  to the original list.

- **`Ne.symm` for `getElem_set_ne`**: After `simp [List.mem_cons, not_or]`,
  `hp.1` has type `¬(p = q)`, but `getElem_set_ne` needs `q ≠ p`. Use
  `Ne.symm hp.1`, not `hp.1.symm` (which tries `Function.symm`).

## Sorry count

- Before: 8 (3 in DeflateEncodeDynamic, 5 in DeflateFixedCorrect)
- After: 6 (1 in DeflateEncodeDynamic, 5 in DeflateFixedCorrect)
- Delta: -2

## Verification

- `lake build`: success (no errors)
- `lake exe test`: all tests passed
- Remaining sorry in DeflateEncodeDynamic: `encodeDynamicTrees_decodeDynamicTables`
  (the main roundtrip theorem that uses these helpers)
