# 2026-02-19: Phase 2 start — pure Lean DEFLATE decompressor

**Type**: implementation
**Phase**: Phase 2 (DEFLATE decompressor) — in progress
**Sorry count**: 0 → 0

**Accomplished**:
- Implemented `Zip/Native/BitReader.lean`: LSB-first bit-level reader for
  ByteArray with readBit, readBits (up to 25), byte-aligned reads
- Implemented `Zip/Native/Inflate.lean`: complete DEFLATE (RFC 1951)
  decompressor supporting all three block types (stored, fixed Huffman,
  dynamic Huffman). Includes canonical Huffman tree construction, LZ77
  back-reference resolution, and code length decoding for dynamic blocks
- Added `ZipTest/NativeInflate.lean`: conformance tests against FFI zlib
  covering levels 0–9, empty, single byte, large (124KB), and pseudo-random
- All 10 test cases pass; native inflate produces identical output to zlib

**Decisions**:
- Used fuel parameter (10M iterations) for Huffman block decoding to
  guarantee termination without `partial`
- Used `Except String` monad for error handling (not `IO`) to keep the
  implementation pure
- Implemented all 3 block types in one session since types 1 and 2 share
  the same Huffman decoding infrastructure

**Bug fixed**:
- `HuffTree.insert` had off-by-one: `go tree (len - 1)` → `go tree len`.
  For an n-bit code, need n branching decisions, not n-1

**Next**:
- Review session for Phase 2 code
- Gzip/zlib framing layer (headers, trailers, checksums)
- Begin DEFLATE spec formalization
