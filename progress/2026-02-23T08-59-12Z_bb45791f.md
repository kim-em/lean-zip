# Progress: Native Level 1 Roundtrip Foundation

**Date**: 2026-02-23 08:59 UTC
**Session**: bb45791f (worker)
**Issue**: #55 — Native Level 1 roundtrip: inflate (deflateFixed data) = .ok data

## What was accomplished

Created `Zip/Spec/DeflateFixedCorrect.lean` with the foundation for the
native Level 1 roundtrip theorem. Key results:

### Fully proved (no sorry in the proof itself)

- **`tokensToSymbols_validSymbolList`**: The symbol list from
  `tokensToSymbols` always satisfies `ValidSymbolList`. Proof: `LZ77Token.toLZ77Symbol`
  never produces `.endOfBlock`, so the mapped list + `[.endOfBlock]` is valid.
- **`tokensToSymbols_length`**: `tokensToSymbols` has length `tokens.size + 1`.

### Proved modulo inherited sorries

- **`tokensToSymbols_encodable`**: Each symbol from `tokensToSymbols (lz77Greedy data)`
  can be fixed-Huffman encoded. Inherits sorry from `lz77Greedy_encodable` (#47).
- **`encodeSymbols_tokensToSymbols_isSome`**: `encodeSymbols` succeeds on
  native tokens. Corollary of above.
- **`lz77Greedy_spec_decode`**: Encoding native LZ77 tokens with fixed Huffman
  then decoding recovers the original data. Uses `encodeFixed_decode` from
  DeflateEncode.lean. Inherits sorries from #47 + `lz77Greedy_size_le`.

### Stated with sorry

- **`lz77Greedy_size_le`**: Token count ≤ data size. Requires reasoning about
  imperative `while` loops in `Id.run do`.
- **`emitTokens_spec`**: Native `emitTokens` ↔ spec `encodeSymbols`. Requires
  `canonicalCodes` ↔ `Huffman.Spec.allCodes` correspondence (both use same
  building blocks `countLengths`/`nextCodes` but different iteration patterns).
- **`deflateFixed_spec`**: Native bytes ↔ spec bits. Depends on `emitTokens_spec`.
- **`inflate_complete`**: Spec decode success → native inflate success. Reverse
  direction of `inflate_correct'`. Very hard.
- **`inflate_deflateFixed`**: The main roundtrip. Depends on `deflateFixed_spec` +
  `inflate_complete`.

## Key decisions

- **Approach A (via spec) is the right path**: The spec-level roundtrip
  (`lz77Greedy_spec_decode`) works cleanly. The missing pieces are the
  native↔spec bitstream correspondence and inflate completeness.
- **canonicalCodes ↔ allCodes is the key missing bridge**: Both functions
  implement RFC 1951 §3.2.2 canonical code construction using the same
  spec building blocks (`countLengths`, `nextCodes`). The native version
  uses an iterative array update; the spec uses offset counting. These are
  equivalent but require a loop invariant proof. This should be a separate
  issue.
- **`inflate_complete` needs a separate focused session**: Proving the
  reverse direction of `inflate_correct'` is substantial — it requires
  constructing a successful native execution path from a spec decode success.
  This could be the subject of multiple sessions.

## Sorry count

- Starting: 2 (both in LZ77NativeCorrect.lean)
- New file: 5 sorry's in DeflateFixedCorrect.lean
- Total: 7 (2 pre-existing + 5 new)

## What remains for issue #55

1. Prove `canonicalCodes` ↔ `allCodes` correspondence (enables `emitTokens_spec`)
2. Prove `emitTokens_spec` and `deflateFixed_spec`
3. Prove `inflate_complete` (or use Approach B: direct byte-level proof)
4. Complete `inflate_deflateFixed`

Items 1-2 could be a separate issue. Items 3-4 are the hardest pieces.
