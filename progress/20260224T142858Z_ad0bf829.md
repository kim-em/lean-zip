# Progress: Review DynamicTreesCorrect + DynamicTreesComplete

**Date**: 2026-02-24T14:28Z
**Session type**: Review (proof quality)
**Issue**: #192

## Accomplished

### Review findings

1. **No dead code**: All helper theorems (`extract_set_map_append`, `fillEntries_*`, `take_set_succ`, `accLen_eq_min`, `extract_map_getLast_eq`) are actively used either internally or by downstream files (DynamicTreesComplete, InflateCorrect).

2. **No unused imports**: The single import `Zip.Spec.DecodeCorrect` is necessary — `symVal_of_beq` and other transitive dependencies are used throughout.

3. **Visibility is correct**: All `private` definitions are only used within DynamicTreesCorrect.lean. All `protected`/public definitions have legitimate cross-file uses.

4. **Major duplication found and fixed**: `_wf` and `_pos_inv` pairs had identical proof structure duplicated across ~120 lines.

### Improvements applied

1. **Merged `readCLCodeLengths_wf` + `readCLCodeLengths_pos_inv`** into `readCLCodeLengths_inv` returning a conjunction. Eliminates duplicate induction/case-split structure.

2. **Merged `decodeCLSymbols_wf` + `decodeCLSymbols_pos_inv`** into `decodeCLSymbols_inv` returning a conjunction. Same pattern, larger savings.

3. **Simplified `h16_false`/`h17_false` proofs** in DynamicTreesComplete from 7-line verbose chains to 4-line `absurd + simpa` one-liners.

### Attempted but not applied

- **Inlining `accLen_eq_min`**: Attempted replacing the named hypothesis with inline `List.length_map, Array.length_toList, Array.size_extract` in simp calls, but `simp only` with these lemmas normalizes differently than the pre-computed hypothesis, causing type mismatches. The named lemma approach is actually cleaner.

## Metrics

- DynamicTreesCorrect.lean: 878 → 788 lines (-90)
- DynamicTreesComplete.lean: 368 → 362 lines (-6)
- Sorry count: unchanged at 1 (DeflateDynamicCorrect.lean)
- `lake build` ✓, `lake exe test` ✓

## Observations for future sessions

- The three sym∈{16,17,18} cases in `decodeCLSymbols_correct` (~130 lines) follow an identical pattern parameterized by (nbits, offset, fillVal). Factoring into a helper lemma could save ~80 lines but requires careful parameterization of the guard conditions (sym==16 has an extra `hprev_eq` + `hguard1`). Worth attempting in a dedicated session.

- Similarly, `decodeCLSymbols_size` has three identical cases that all end with `have := ih br₂ _ _ h; rw [this, fillEntries_size]`. Same factoring opportunity.

- The `show ((N : Nat) == M) = true/false from rfl` pattern in DynamicTreesCorrect could use a helper, but it's explicit and works reliably. Low priority.
