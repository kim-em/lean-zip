# Progress: Complete deflateDynamic_spec — zero-sorry milestone

- **Date**: 2026-02-24 16:47 UTC
- **Session type**: Worker (issue #199)
- **Branch**: `agent/ad0bf829`

## What was accomplished

Completed all 3 remaining sorries in `deflateDynamic_spec`, achieving the
zero-sorry milestone for the entire codebase.

### Sorry #1: encodeDynamicTrees succeeds (completed in earlier session)
Proved that `Deflate.Spec.encodeDynamicTrees litLens distLens` returns
`some _` by establishing that all CL entries have nonzero code lengths
via `computeCodeLengths_nonzero` and `clSymbolFreqs_pos`.

### Sorry #2: encodeSymbols succeeds (completed in earlier session)
Proved that `Deflate.Spec.encodeSymbols litLens distLens (tokensToSymbols tokens)`
returns `some _`. Required new helper lemmas:
- `tokenFreqs_go_litCode_pos` / `tokenFreqs_litCode_pos`: literal frequency > 0
- `tokenFreqs_go_distCode_pos` / `tokenFreqs_distCode_pos`: distance frequency > 0
- `encodeSymbol_canonicalCodes_eq`: bridge native canonical codes ↔ spec encode

### Sorry #3: bytesToBits correspondence (completed this session)
Proved the key decomposition:
```
bytesToBits (deflateDynamic data) =
    [true, false, true] ++ headerBits ++ symBits ++ padding
```
Following the `deflateFixedBlock_spec` template:
1. Split `symBits` via `encodeSymbols_append_inv` into `tokBits ++ eobBits`
2. Build canonical codes with size/bound properties
3. Chain BitWriter operations through wf/toBits lemmas
4. Show `deflateDynamic data = (bw.writeHuffCode eob).flush` via
   `unfold deflateDynamic; split` — the else branch is `rfl`, the
   data.size=0 branch needs `emitTokensWithCodes` identity on empty tokens
5. Use `flush_toBits` to convert to `bytesToBits` form

### Supporting work
- Fixed `writeCLEntries_wf`: ih argument mismatch (needed `_` for `bw` arg
  after `induction ... generalizing bw`)
- Fixed `writeDynamicHeader_wf`: `List.size_toArray` (not `length_toArray`),
  `Nat.le_trans` (not `le_trans`), explicit type annotation for omega
- New helpers in `DeflateEncodeDynamicProps.lean`:
  - `rlEncodeLengths_valid`: all RLE entry codes ≤ 18
  - `clSymbolFreqs_length`: CL frequency array has exactly 19 entries
  - `clSymbolFreqs_pos`: CL entry code has positive frequency
  - `encodeCLEntries_isSome`: CL encoding succeeds with valid entries
- New helper in `EmitTokensCorrect.lean`:
  - `canonicalCodes_snd_le'`: code length bound with explicit maxBits

## Key proof patterns discovered

- **Pair pattern match in `unfold`**: `deflateDynamic` has
  `let (litFreqs, distFreqs) := tokenFreqs tokens` which creates
  `match ... with | (a, b) => ...` after `unfold`. This is definitionally
  equal to using `.1`/`.2`, so `unfold f; split` + `rfl` works for the
  non-empty branch. The empty branch needs explicit work to show
  `emitTokensWithCodes` is identity on empty tokens.
- **`beq_iff_eq` for `split` branch**: After `split` on `if data.size == 0`,
  the hypothesis has type `(data.size == 0) = true`. Use
  `rw [beq_iff_eq] at hzero` to get `data.size = 0`.

## Sorry count
- Before: 3 (all in DeflateDynamicCorrect.lean)
- After: 0
- Delta: -3

## What remains
- Zero sorries in the entire Zip/ directory
- All tests pass
