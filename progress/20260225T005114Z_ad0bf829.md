# Progress: Prove BitReader invariant lemmas + inflateLoop_endPos_le

**Issue**: #247 (feature)
**PR**: #259
**Branch**: agent/ad0bf829
**Starting commit**: fc92c81
**Starting sorry count**: 10 (8 GzipCorrect + 2 ZlibCorrect)
**Ending sorry count**: 3 (1 GzipCorrect + 2 ZlibCorrect)

## Completed

All 5 deliverables from issue #247:

1. **`decodeStored_inv`** — Proved that `decodeStored` preserves the BitReader
   invariant (data unchanged, bitOff=0 ∨ pos<data.size, pos≤data.size).
   Decomposed into `readUInt16LE_inv` and `readBytes_inv` helpers.
   Key technique: `by_cases` on `unless` conditions + `simp only [pure, Except.pure]`
   to normalize do-notation patterns.

2. **`decodeHuffman_go_inv`** — Proved fuel-based induction on the Huffman decoder.
   Key technique: `unfold` + `dsimp only [Bind.bind, Except.bind]` to desugar
   do-notation without triggering recursive simp looping, followed by
   `split at h` decomposition of the nested match tree. `simp only [Except.bind]`
   with the recursive function caused infinite loops.

3. **`decodeCLSymbols_inv`** — Same pattern as `decodeHuffman_go_inv`: fuel induction,
   unfold + dsimp, then split-based case analysis on sym < 16 / == 16 / == 17 / == 18.

4. **`decodeDynamicTrees_inv`** — Sequential chain proof: readBits (×3) →
   readCLCodeLengths → decodeCLSymbols, using split to decompose each bind.

5. **`inflateLoop_endPos_le`** — The main theorem. Uses fuel induction with a
   factored `bfinal_or_recurse` helper for the common bfinal/recurse pattern.
   Dispatches by block type (stored/fixed/dynamic/reserved) using split.
   Also proved the `startPos ≤ data.size` prerequisite in `inflateRaw_endPos_le`
   by contradiction (readBit errors when pos ≥ data.size).

**Bonus**: Added `decodeHuffman_inv` wrapper (unfolds `decodeHuffman` to `.go`)
to avoid maxRecDepth issues from the 10000000 default fuel literal.

## Techniques Learned

- `unfold F at h; dsimp only [Bind.bind, Except.bind] at h` is the safe pattern
  for desugaring do-notation in hypotheses involving recursive functions.
  Using `simp only [F, bind, Except.bind]` loops because the simplifier
  re-unfolds recursive calls.
- `simp only [pure, Except.pure] at h` eliminates `match pure PUnit.unit` patterns
  from `unless` checks without touching recursive calls.
- `split at h` works directly on `match` expressions in hypotheses — no need to
  `cases` on the discriminant separately.
- Large Nat literals (10000000) cause `maxRecDepth` during elaboration. Use `unfold`
  to expose the literal in a hypothesis, then pass `_` for the fuel parameter.

## Sorry Count Change

| File | Before | After | Change |
|------|--------|-------|--------|
| GzipCorrect.lean | 8 | 1 | -7 |
| ZlibCorrect.lean | 2 | 2 | 0 |
| **Total** | **10** | **3** | **-7** |

Note: The remaining GzipCorrect sorry is `gzip_decompressSingle_compress` (the gzip
roundtrip theorem), which depends on `inflateLoop_endPos_le` being proved first —
now unblocked by this session.
