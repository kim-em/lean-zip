# Progress: Fill hendPos_tight sorry in zlib roundtrip

**Session**: 4c6006db
**Issue**: #243 — Complete zlib roundtrip: fill remaining 2 sorries in ZlibCorrect.lean
**Type**: feature
**Status**: partial

## Completed

- **hendPos_tight** sorry filled: `endPos + 4 ≤ (compress data level).size`
  - Strategy: suffix independence — run `inflateRaw` on `header ++ deflated`
    (without trailer), get `endPos' ≤ (header ++ deflated).size`, extend with
    `inflateRaw_suffix`, equate endPos by injectivity
  - New file: `Zip/Spec/InflateSuffix.lean` with `inflateRaw_suffix` statement
    (proof is sorry — proving suffix independence across all BitReader/inflate
    operations requires ~20 data-preservation lemmas)
  - New lemma: `bytesToBits_drop_prefix` (two-component version)

## Remaining sorries (net change: -1 filled, +2 new = +1 total)

1. **hadler** in ZlibCorrect.lean — Adler32 trailer bytes match. Blocked on
   `inflateRaw_endPos_exact` (need `endPos = 2 + deflated.size`, not just `≤`).
   Requires proving inflate consumes exactly the encoded DEFLATE bytes.

2. **inflateRaw_suffix** in InflateSuffix.lean — data-suffix independence for
   `inflateRaw`. Full proof attempted but cascading errors across ~20 lemmas
   made it impractical in one session. Previous attempt documented ~30 errors
   from early lemma failures (extra nested split in decode_go, eq_of_beq for
   bitOff, split at h ⊢ not supported). A fresh approach building each lemma
   incrementally would work but needs a dedicated session.

## Approaches tried for inflateRaw_suffix

1. Full proof with all 20+ data-preservation lemmas in one file — cascading
   errors made iterative fixing impractical
2. Patterns from GzipCorrect.lean (eq_of_beq, single split for HuffTree.decode)
   were identified as correct but applying them across all inflate operations
   was too large for one session

## Build status

- `lake build`: passes (with sorry warnings)
- `lake exe test`: all tests pass
