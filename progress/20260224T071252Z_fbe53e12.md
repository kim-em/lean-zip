# Progress: Prove decodeHuffman_complete literal and endOfBlock cases

- **Date**: 2026-02-24T07:12Z
- **Session type**: Implementation (worker)
- **Issue**: #150 — Prove decodeHuffman_complete length/distance case

## Accomplished

### Completed deliverables

1. **decode_go_complete** (HuffmanCorrect.lean): Proved reverse direction of
   tree decode — if `TreeHasLeaf tree cw sym` and bits start with `cw`,
   then `decode.go` succeeds returning `sym`. (commit b83f3c1)

2. **huffTree_decode_complete** (DecodeCorrect.lean): Proved that if the
   spec-level Huffman decode succeeds, the native `HuffTree.decode` also
   succeeds with the corresponding result. Uses `decode_go_complete`,
   `fromLengths_hasLeaf`, and `readBits_complete` for codeword length
   bounds. (commit 8749bfc)

3. **decodeHuffman_complete literal case**: Full proof that if the spec
   decodes a literal byte, the native decoder does too. Uses
   `decodeLitLen_literal_inv` helper, `resolveLZ77_extends` for output
   size bounds, and the IH. (commit 067c424)

4. **decodeHuffman_complete endOfBlock case**: Full proof that if the spec
   decodes an end-of-block marker, the native decoder returns the current
   output. Key techniques: ByteArray extensionality via `congrArg`,
   `UInt16.toNat_inj` for beq proof, `Nat.not_lt.mpr` instead of omega
   (which chokes on UInt16 hypotheses in context). (commit 067c424)

5. **decodeLitLen_reference_inv** helper: Extracts all 9 intermediate
   values from a successful reference decode path in `decodeLitLen`
   (length base/extra/extraVal, distance Huffman decode, distance
   base/extra/extraVal). Required `set_option maxRecDepth 4096` for the
   deeply nested existential. (commit 8fc9381)

### Not completed

6. **decodeHuffman_complete reference case**: Left as `sorry`. This case
   requires ~100 lines and needs:
   - Table correspondence lemmas from DeflateFixedTables (currently
     `private`, need to be made `protected`)
   - Two `readBits_complete` applications (length and distance extra bits)
   - `huffTree_decode_complete` for the distance tree
   - `copyLoop_eq_ofFn` for back-reference copy correspondence
   - `resolveLZ77` reference case unfolding
   - The `decodeLitLen_reference_inv` helper (already written) provides
     the spec-side extraction

   This case needs a new issue to be planned.

## Key patterns discovered

- **omega + UInt16**: omega scans ALL hypotheses. If any hypothesis
  contains `sym_nat.toUInt16` and `hsym_eq : sym_nat = 256` is in
  context, omega creates an opaque `UInt16.toNat 256` variable it can't
  evaluate. Fix: use `Nat.lt_of_lt_of_le hsym_bound hlen_lit` directly
  instead of omega, or use `Nat.not_lt.mpr Nat.le.refl` for `¬(256 < 256)`.

- **ByteArray extensionality**: To prove `output = ⟨⟨result⟩⟩` from
  `output.data.toList = result`, use
  `congrArg (fun x => ByteArray.mk (Array.mk x)) hlz`. The `ext1; ext1`
  pattern fails because `Array.ext` requires size equality first.

- **Deeply nested existentials**: 9+ existentials with `exact ⟨...⟩` hit
  `maxRecDepth`. Use `set_option maxRecDepth 4096 in` before the theorem.

- **`cases` substitution and `rfl`**: After `cases hlb : f[i]? with
  | some base =>`, the goal's `f[i]?` is substituted to `some base`,
  so use `rfl` not `hlb` in the proof term.

## Sorry count

- Start: 9
- End: 8 (net -1)
- The removed sorry is in `decodeHuffman_complete` (literal + endOfBlock
  cases proved). The reference case sorry remains.

## Files changed

- `Zip/Spec/HuffmanCorrect.lean`: +38 lines (decode_go_complete)
- `Zip/Spec/DecodeCorrect.lean`: +354 lines (main proofs + helpers)
- `Zip/Spec/BitstreamCorrect.lean`: +4/-4 (visibility fix)
