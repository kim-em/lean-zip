# Progress: Rebase PR #155 and prove fixedLitCodes/fixedDistCodes_snd_le

- **Date**: 2026-02-24 06:35 UTC
- **Session type**: Worker (issue #156)
- **Branch**: `agent/9bcd7947`
- **Starting commit**: `a3634e8`
- **Starting sorry count**: 9

## What was accomplished

### Rebased PR #155 onto current master

PR #155 had merge conflicts with master after PR #154 split
`DeflateFixedCorrect.lean`. A normal `git rebase` failed due to
complex conflicts (the file had been restructured). Instead, manually
applied PR #155's changes on top of master:

1. `Deflate.lean`: `protected def deflateFixedBlock` → `def deflateFixedBlock`
2. `HuffmanEncodeCorrect.lean`: `private` → `protected` on `canonicalCodes_go_size`,
   updated recursive calls to use fully qualified `Deflate.Correctness.canonicalCodes_go_size`
3. `DeflateFixedCorrect.lean`: Applied all new lemmas and the full
   `deflateFixed_spec` proof from PR #155

### Proved fixedLitCodes_snd_le and fixedDistCodes_snd_le

These were `sorry` placeholders in the original PR. The proof strategy:

1. **`canonicalCodes_go_snd_le`**: Inductive proof that `canonicalCodes.go`
   preserves a bound on `.snd.toNat` — if all initial result entries and
   all input lengths satisfy `≤ bound`, so do all output entries. Key
   challenge was handling `getElem!_pos` type class synthesis with
   `Array.set!` — needed explicit container arguments and careful
   `by_cases heq : k = i` splitting with `Ne.symm` for `¬(i = k)` vs `¬(k = i)`.

2. **`fixedLitLengths_le_15`**: Structural proof decomposing
   `fixedLitLengths` (an append of 4 arrays) using
   `Array.getElem_append_left/right` and `Array.getElem_replicate`.
   Avoids expensive `decide` on `Fin 288`.

3. **`fixedDistLengths_le_15`**: Simple proof using `Array.getElem_replicate`
   since `fixedDistLengths = Array.replicate 32 5`.

4. **`canonicalCodes_snd_le`**: Wrapper applying `canonicalCodes_go_snd_le`
   with initial `Array.replicate` (all entries `(0,0)` satisfy any bound).

### Other improvements

- Generalized `encodeSymbols_append_singleton` to `encodeSymbols_append`
  (arbitrary list concatenation, not just singleton)
- Added `encodeSymbols_singleton` helper for single-symbol encoding
- Added bounds lemmas: `findTableCode_go_idx_bound`,
  `nativeFindLengthCode_idx_bound/extraN_bound`,
  `nativeFindDistCode_idx_bound/extraN_bound`
- Simplified `emitTokens_wf_go` to use direct bounds instead of encoding dependency

## Decisions made

- Manual rebase instead of `git rebase`: the file restructuring from PR #154
  made automatic conflict resolution impractical
- Used `getElem!_pos` with explicit container arguments throughout to avoid
  `GetElem? Nat Nat` type class synthesis failures
- Used `Ne.symm` to flip `¬(k = i)` to `¬(i = k)` for matching
  `Array.getElem_set` conditions

## Proof patterns discovered

- **`Array.getElem_set` condition direction**: After `simp` with
  `Array.getElem_set`, the resulting `if` condition is `i = k` (index
  being set = index being accessed). When you have `heq : ¬(k = i)` from
  a `by_cases`, use `Ne.symm heq` to get `¬(i = k)` for `↓reduceIte`.

## Sorry count

- Before: 9 (4 DeflateFixedCorrect, 2 DecodeCorrect, 2 InflateCorrect, 1 DynamicTreesCorrect)
- After: 8 (3 DeflateFixedCorrect, 2 DecodeCorrect, 2 InflateCorrect, 1 DynamicTreesCorrect)
- Delta: -1 (proved `deflateFixed_spec` + both `snd_le` lemmas)

## Deliverables

- [x] Rebase PR #155 onto current master
- [x] Resolve merge conflicts
- [x] Prove `fixedLitCodes_snd_le`
- [x] Prove `fixedDistCodes_snd_le`
- [x] Force-push rebased branch

## What remains

- CI pending on PR #155 (auto-merge enabled)
