# 2026-02-20: Implementation — IsPrefixFree bridge + ValidLengths + decode correctness

**Type**: implementation
**Phase**: Phase 3 (verified decompressor) — in progress
**Sorry count**: 0 → 0

**Accomplished** (4 commits, +193 lines):

- **allCodes ↔ IsPrefixFree bridge** (Huffman.lean): Proved that the
  codewords from `allCodes` form a prefix-free list (`allCodeWords_prefix_free`).
  Supporting lemmas: `allCodes_mem_iff` (membership characterization),
  `allCodes_nodup` (no duplicate entries via `Pairwise.filterMap` on
  `nodup_range`), `allCodes_prefix_free_of_ne` (membership-based API).

- **ValidLengths for fixed codes** (Deflate.lean): Proved
  `fixedLitLengths_valid` (288-symbol table, Kraft sum = 2^15) and
  `fixedDistLengths_valid` (32-symbol table). Both verified by `decide`;
  the 288-element case needs `maxRecDepth 2048` (~900ms).

- **Decode correctness** (Huffman.lean): Proved `decode_prefix_free` —
  in a prefix-free code table, `decode (cw ++ rest) = some (sym, rest)`
  for matching entry `(cw, sym)`. Required `IsPrefix_dichotomy` (two
  prefixes of the same list are comparable) and `isPrefixOf_self_append`.

- **Prefix-free corollaries** (Deflate.lean): One-liner proofs that
  fixed lit/length and distance codes are prefix-free.

**Codex review**: Two issues flagged, neither actionable:
1. maxBits = 15 for distance codes — matches actual usage in codeFor/allCodes
2. Nodup/Pairwise fragility — Nodup IS Pairwise (· ≠ ·) by definition

**Key techniques**:
- `Pairwise.filterMap` + `nodup_range` avoids needing a dedicated
  `Nodup.filterMap` lemma (which doesn't exist in std)
- `List.pairwise_iff_getElem` converts Nodup-based reasoning to index-based
- `by_cases heq : entry = (cw, sym)` handles the edge case of duplicate
  entries in the decode proof cleanly

**Next**: State main correctness theorem, prove resolveLZ77 properties,
or review session on Native/ code.
