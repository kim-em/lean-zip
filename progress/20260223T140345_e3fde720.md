# Progress: Dynamic Tree Header Roundtrip (BB4)

- **Date**: 2026-02-23 14:03 UTC
- **Session**: worker (issue #100)
- **Branch**: `agent/e3fde720`
- **Starting commit**: `ab48dd6`

## Accomplished

Proved the core inductive roundtrip lemma `encodeCLEntries_decodeCLSymbols_go`,
which connects CL entry encoding (via the CL Huffman table) to `decodeCLSymbols`
decoding. This is the hardest sub-lemma for the dynamic tree header roundtrip
(BB4).

### Key results (across this + prior sessions on this branch)

1. **`readCLLengths_writeCLLengths`** (commit `cda1322`): CL code length
   write/read roundtrip through the permuted 3-bit encoding
2. **`rlDecodeLengths_go_mono`** and **`rlDecodeLengths_go_strict_mono`**
   (commit `6c19dd3`): RLE decoder accumulator monotonicity
3. **`encodeCLEntries_decodeCLSymbols_go`** (commit `cf504d0`): The main
   inductive lemma. Handles all CL code cases:
   - Literal codes (≤15): `encodeSymbol_decode` + IH
   - Code 16 (repeat previous): guard proof, `rlDecode_go_code16`,
     `getLast?_getD_eq_getLast!` bridging lemma
   - Code 17 (repeat 0, 3-10×): `rlDecode_go_code17` + guard reduction
   - Code 18 (repeat 0, 11-138×): `rlDecode_go_code18` + guard reduction
4. **Helper lemma stubs** (commit `5fc94e4`):
   - `computeHCLEN_trailing_zero`: trailing permuted positions have value 0
   - `readCLLengths_recovers_clLens`: foldl-set recovers original CL lengths
   - `clPermutation_nodup`, `clPermutation_lt_nineteen` (both proved by `decide`)

### Main theorem status

`encodeDynamicTrees_decodeDynamicTables` remains sorry'd. The proof requires
composing all sub-lemmas:
1. `readBitsLSB_writeBitsLSB` for hlit/hdist/hclen (trivial)
2. `readCLLengths_writeCLLengths` for CL code lengths (proved)
3. `readCLLengths_recovers_clLens` to show decoded CL lengths = encoder's clLens (sorry'd)
4. `encodeCLEntries_decodeCLSymbols_go` for CL entry decoding (proved)
5. Guard and take/drop for final splitting (trivial)

Step 3 is the remaining non-trivial piece — requires showing that `computeHCLEN`
captures all non-zero positions so the foldl-set recovers the original list.
Also needs `computeHCLEN_trailing_zero` which requires a lemma about
`List.reverse.takeWhile` and element access.

## Proof patterns discovered

- **Two-step guard reduction**: When Option do-notation has `guard (cond)`,
  after `simp` reduces the surrounding structure, prove `cond` separately with
  `have : cond := ...` then `simp [this]` (or `simp only [this, ↓reduceIte]`).
- **`getLast!` vs `getLast?.getD 0`**: These are propositionally but NOT
  definitionally equal. Need a bridging lemma to convert between them.
- **`failure.bind` contradiction**: When `hdec` contains `failure.bind f = some _`,
  close with `simp [failure, bind, Option.bind] at hdec`.

## Sorry count

- **Start**: 11 (5 DeflateFixedCorrect, 5 DeflateStoredCorrect, 1 DeflateEncodeDynamic)
- **End**: 13 (5 + 5 + 3 in DeflateEncodeDynamic)
- **Delta**: +2 net (added 2 helper lemma stubs, main theorem stays sorry'd)
- The 2 new sorry's are: `computeHCLEN_trailing_zero`, `readCLLengths_recovers_clLens`
- The original sorry (`encodeDynamicTrees_decodeDynamicTables`) remains

## What remains for BB4

1. Prove `computeHCLEN_trailing_zero` (needs reverse.takeWhile property)
2. Prove `readCLLengths_recovers_clLens` (needs clPermutation is permutation of range 19)
3. Compose everything in `encodeDynamicTrees_decodeDynamicTables`
