# Progress: canonicalCodes ↔ allCodes Huffman code correspondence

- **Date**: 2026-02-23 UTC
- **Session type**: Worker (implementation)
- **Issue**: #83

## What was accomplished

Created `Zip/Spec/HuffmanEncodeCorrect.lean` with complete proofs (0 sorries):

1. **`canonicalCodes_go_size`**: Size preservation — `canonicalCodes.go` preserves
   the result array size through recursion.

2. **`canonicalCodes_go_inv`**: Main loop invariant proving that at each step:
   - NextCode array tracks `ncSpec + partial offset` (NC invariant)
   - Processed entries match spec's `codeFor` computation
   - Unprocessed entries remain `(0, 0)`

3. **`initial_nc_invariant`**: Proves the initial NextCode state
   (`ncSpec.map (·.toUInt32)`) satisfies the NC invariant.

4. **`canonicalCodes_correct_pos`**: For symbols with nonzero code length,
   `canonicalCodes` produces the same code value as `codeFor`.
   Requires `maxBits < 16` for UInt16 faithfulness.

5. **`canonicalCodes_correct_zero`**: For symbols with zero code length,
   `canonicalCodes` stores `(0, 0)`.

6. **`canonicalCodes_hasLeaf`**: Bridge theorem connecting the native encoder's
   stored codes to decoder tree leaves via `fromLengths_hasLeaf`.

## Key proof techniques

- **`by_cases` instead of `split` for nested `if`**: After `unfold` + `dsimp`,
  the goal has multiple `if` expressions. `split` captures the outermost one
  (from the conclusion), not the function body's. `by_cases hlen_pos : lengths[i] > 0`
  explicitly targets the correct condition.

- **`simp only [hk_eq]` for dependent type rewriting**: `rw [hk_eq]` fails on
  `lengths[k]` because the array access depends on `hks : k < lengths.size`.
  `simp only [hk_eq]` handles dependent type rewriting via congr lemmas.

- **UInt16 faithfulness bound**: `maxBits < 16` ensures `ncSpec + count ≤ 2^len
  ≤ 2^15 = 32768 < 65536 = 2^16`, making `UInt32.toUInt16.toNat` faithful.

## Sorry count

- Start: 10
- End: 10
- Delta: 0 (new file has 0 sorries; no existing sorries changed)
