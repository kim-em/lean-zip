# Progress Entry

- **Date**: 2026-02-23 06:06 UTC
- **Session type**: Worker (implementation)
- **Issue**: #22 — BB1: Spec-level greedy LZ77 matcher and fundamental theorem

## What was accomplished

Implemented the spec-level greedy LZ77 encoder and proved the fundamental
roundtrip theorem in `Zip/Spec/Deflate.lean` (+320 lines, total 835).

### Definitions added
- `matchLength` — count consecutive matching bytes at two positions with
  modular wrapping for overlapping copies
- `findLongestMatch` — scan distances 1..min(pos,windowSize) for longest
  match of length ≥ 3
- `matchLZ77` — greedy LZ77 encoder: emit longest match or literal at
  each position, end with endOfBlock

### Theorems proved (no new sorries)
- `matchLength.go_bounds` — return value in [count, maxLen]
- `matchLength.go_correct` — all counted positions have matching bytes
- `matchLength.go_in_bounds` — all counted positions are in-bounds
- `matchLength_correct` / `matchLength_in_bounds` — outer wrappers
- `findLongestMatch.go_inv` — loop invariant for distance scanning
- `findLongestMatch_len_ge` — result length ≥ 3
- `findLongestMatch_dist_bounds` — 1 ≤ dist ≤ pos
- `findLongestMatch_matchLength` — matchLength agrees with result
- `take_append_copied_eq_take` — key lemma: modular copy reproduces
  original data when source matches
- `matchLZ77.go_correct` — inner correctness with accumulator invariant
- `resolveLZ77_matchLZ77` — fundamental theorem:
  `resolveLZ77 (matchLZ77 data ws) [] = some data`

## Key proof patterns

- **`take_append_copied_eq_take`**: The hardest lemma. Uses `List.take_add`
  to decompose `List.take (pos + len) data` into `List.take pos data ++ ...`,
  then `congr 1` + `List.ext_getElem` with `getElem_ofFn`/`getElem_drop`
  to show the `List.ofFn` segment matches `List.drop pos data |>.take len`.
- **matchLength correctness**: Reformulated to use Option equality
  (`data[pos+i]? = data[src]?`) instead of existential witnesses to avoid
  dependent elimination failures with pair matching.
- **`getElem!_pos` not `List.getElem!_pos`**: The constant lives in
  `Init.GetElem`, not under `List.` namespace.

## Verification

- `lake build Zip.Spec.Deflate` — succeeds
- Sorry count: 1 (unchanged, pre-existing `encodeStored_decode`)
- File size: 835 lines (well under 1000 limit)

## What remains

- The `encodeStored_decode` sorry (pre-existing, out of scope)
- Future: proofs connecting `matchLZ77` output to actual DEFLATE encoding
