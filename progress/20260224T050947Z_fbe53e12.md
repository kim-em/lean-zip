# Progress: 2026-02-24T05:09Z — Worker session fbe53e12

## Issue
#132 — Prove stored-block completeness: readUInt16LE_complete, readBytes_complete, decodeStored_complete

## Accomplished

All three deliverables completed:

1. **readUInt16LE_complete** (BitstreamCorrect.lean): Proved that if spec
   `readBitsLSB 16 (alignToByte br.toBits) = some (val, rest)`, then native
   `readUInt16LE` succeeds. Key technique: decompose 16-bit read into two
   8-bit reads via `readBitsLSB_split`, use `toBits_readBitsLSB_byte` for each,
   bridge `Nat.or` to addition via `Nat.shiftLeft_add_eq_or_of_lt`.

2. **readBytes_complete** (BitstreamCorrect.lean): Proved that if spec
   `readNBytes n (alignToByte br.toBits) [] = some (bytes, rest)`, then native
   `readBytes` succeeds. Added precondition `halign_pos : br.alignToByte.pos ≤
   br.alignToByte.data.size` — theorem is false without it (n=0, pos > data.size
   edge case). Also added helper lemmas:
   - `readNBytes_some_length`: readNBytes needs ≥ n*8 bits
   - `readNBytes_output_length`: output list length = acc.length + n

3. **decodeStored_complete** (DecodeCorrect.lean): Proved that if spec
   `decodeStored` succeeds, native `Inflate.decodeStored` also succeeds with
   the same output. Chains readUInt16LE_complete twice (LEN, NLEN) and
   readBytes_complete once, bridging complement check and size check.

## Key decisions

- Added `halign_pos` precondition to `readBytes_complete` after discovering
  the theorem is false for the edge case n=0, pos > data.size (spec readNBytes
  0 succeeds trivially but native readBytes 0 checks pos ≤ data.size).
- For `halign_pos2` in decodeStored_complete, unfolded readUInt16LE internals
  to extract the bounds check rather than using a separate lemma.
- Used `readUInt16LE_data` lemma to bridge `br1.data = br.data` for omega.

## Sorry count

Start: 11, End: 8 (removed 3)

## What remains

Nothing — all deliverables complete.
