# Progress Entry

- **Date**: 2026-02-25 UTC
- **Session type**: Worker (implementation)
- **Issue**: #131 — Write deflateDynamic_spec and prove inflate_deflateDynamic

## What was accomplished

### Completed deliverables

1. **`writeCLLengths_go_spec`** — proved native→spec correspondence for the
   CL code length writing loop in the dynamic Huffman header.

2. **`writeCLEntries_spec`** — fixed and proved native→spec correspondence
   for the CL entry encoding loop (codes 16/17/18 with extra bits).
   Key fix: threading `hext` (bounds on extras) through recursive `ih` calls.

3. **`encodeDynamic_decode_append`** — proved dynamic Huffman block decode
   roundtrip with trailing bits (in DeflateEncode.lean), analogous to
   `encodeFixed_decode_append`. Also proved `readBitsLSB_2_false_true`
   helper for btype=2 parsing.

4. **`writeDynamicHeader_spec`** — theorem structure established with
   `encodeDynamicTrees` result extraction proven. Body left as `sorry`
   (needs BitWriter chain through HLIT/HDIST/HCLEN writes + CL lengths
   + CL entries).

5. **`deflateDynamic_spec`** — theorem signature established. Existentially
   produces litLens, distLens, headerBits, symBits with all needed
   properties. Body `sorry` (needs proof that `computeCodeLengths`
   assigns nonzero code lengths to symbols with nonzero frequency).

6. **`inflate_deflateDynamic`** — fully proved modulo the two sorry helpers
   above. Uses `deflateDynamic_spec` → `encodeDynamicTrees_decodeDynamicTables`
   → `encodeDynamic_decode_append` → `inflate_complete`.

### Not completed

- **`writeDynamicHeader_spec` body**: The structure is right (extracting
  `symbolBits` from `encodeDynamicTrees` via `cases`/`rw`/`simp`), but the
  actual BitWriter chain proof is not done. Needs chaining `writeBits_toBits`
  for HLIT/HDIST/HCLEN, then `writeCLLengths_go_spec`, then
  `writeCLEntries_spec` with proper `wf` threading and `Nat.toUInt32.toNat`
  roundtrip for the header values.

- **`deflateDynamic_spec` body**: Blocked on a missing lemma about
  `computeCodeLengths`: "symbols with nonzero frequency get nonzero code
  lengths." This property ensures `encodeDynamicTrees` and `encodeSymbols`
  succeed for the specific litLens/distLens computed from token frequencies.
  Without this, we can't prove the existential.

## Key proof patterns discovered

- **`List.mem_cons_self` takes zero explicit arguments**: All parameters are
  implicit. Use `List.mem_cons_self` not `List.mem_cons_self _ _`.

- **Option do-block in `encodeDynamicTrees`**: After `unfold` and guard
  reduction, the `let x ← encodeCLEntries ...` produces a nested match.
  Use `cases hcle : encodeCLEntries ...; rw [hcle] at henc; simp at henc`
  to split and reduce.

- **Circular import avoidance**: `DeflateDynamicCorrect` imports
  `DeflateFixedCorrect`, so `inflate_deflateDynamic` was moved from
  `DeflateFixedCorrect` to `DeflateDynamicCorrect`.

## Sorry count

- Start: 1 (inflate_deflateDynamic — the other two were proved in PR #184)
- End: 2 (writeDynamicHeader_spec, deflateDynamic_spec — new sorry helpers)
- Net: +1 (but inflate_deflateDynamic is now proved modulo these helpers)

## What remains

Issue #131 is partially resolved. The top-level theorem
`inflate_deflateDynamic` is proved but depends on two sorry helpers.
A new issue should cover:
1. Proving `computeCodeLengths` assigns nonzero lengths to nonzero-frequency
   symbols (unblocks `deflateDynamic_spec`)
2. Completing the BitWriter chain in `writeDynamicHeader_spec`
