# Progress: Prove DeflateEncodeDynamic sorries

- **Date**: 2026-02-24 03:24 UTC
- **Session type**: Worker (implementation)
- **Issue**: #110

## Accomplished

Proved all 3 sorry'd theorems in `Zip/Spec/DeflateEncodeDynamic.lean`,
completing the dynamic Huffman tree header encode→decode roundtrip:

1. **`computeHCLEN_trailing_zero`**: Positions past `computeHCLEN` in the
   CL permutation order have value 0. Proved using `List.IsPrefix.getElem`,
   `List.takeWhile_append_dropWhile`, and `List.getElem_reverse`. Required
   helper `reverse_takeWhile_getElem`.

2. **`readCLLengths_recovers_clLens`**: The foldl-set reconstruction on
   `List.replicate 19 0` using `clPermutation.take numCodeLen` recovers the
   original CL lengths. Proved via `List.ext_getElem` with helpers for
   foldl-set properties (`foldl_set_length`, `foldl_set_getD_nmem`,
   `foldl_set_getD_mem`) and `clPermutation_mem_all` (by `decide`).

3. **`encodeDynamicTrees_decodeDynamicTables`**: The main orchestration
   proof connecting encoder to decoder through `readBitsLSB_writeBitsLSB`,
   `readCLLengths_writeCLLengths`, `readCLLengths_recovers_clLens`,
   `encodeCLEntries_decodeCLSymbols_go`, and take/drop split.

## Key decisions

- **Spec bug fix**: Changed `decodeDynamicTables` fuel from `totalCodes` to
  `totalCodes + 1`. The CL symbol decoder needs one fuel unit per Huffman
  symbol decoded plus one for the final base-case length check. With
  `fuel = totalCodes`, worst-case all-literal RLE encodings (no compression,
  `clEntries.length = allLens.length`) would cause the decoder to return
  `none`. Updated `DynamicTreesCorrect.lean` to bridge via
  `decodeCLSymbols_fuel_independent`.

- **`rlEncodeLengths_length_le`**: Added proof that RLE encoding never
  produces more entries than input length, needed for the fuel bound.

## Proof patterns discovered

- **`letFun` in `unfold` output**: When `unfold rlEncodeLengths.go` produces
  `have runLen := ...; if runLen ≥ 11 then ...`, `split` can't see through
  the `have` binding. Use `simp only [letFun]` first to inline it.

- **2-arg match reduction**: After `simp only [decodeDynamicTables, bind,
  Option.bind]`, the do-notation desugars to 2-arg matches
  `match result, fun __discr => ... with | none, _ => | some a, f => f a`.
  After rewriting `result` to `some val`, use `simp only []` (empty simp)
  to beta-reduce the match.

## What remains

- Sorry count: 8 → 5 (all in `DeflateFixedCorrect.lean`)
- All deliverables from issue #110 completed

## Verification

- `lake build`: clean (no errors, only pre-existing warnings)
- `lake exe test`: all tests pass
- Sorry delta: -3
