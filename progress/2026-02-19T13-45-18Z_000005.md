# 2026-02-19: Implementation — gzip/zlib framing layer

**Type**: implementation
**Phase**: Phase 2 (DEFLATE decompressor) — feature-complete
**Sorry count**: 0 → 0

**Accomplished**:
- Refactored `Inflate.inflate` into `inflateRaw` (returns ending byte position)
  + `inflate` wrapper. This enables framing layers to read trailers after the
  DEFLATE stream.
- Implemented `Zip/Native/Gzip.lean`:
  - `GzipDecode.decompress`: Full RFC 1952 gzip header/trailer parsing, including
    FEXTRA, FNAME, FCOMMENT, FHCRC optional fields. CRC-32 and ISIZE verification.
    Supports concatenated gzip members.
  - `ZlibDecode.decompress`: RFC 1950 zlib header parsing (CMF+FLG check bits,
    compression method, window size). Adler-32 trailer verification (big-endian).
  - `detectFormat`: Auto-detects gzip/zlib/raw-deflate from first bytes.
  - `decompressAuto`: Dispatches to the right decompressor based on format.
- Added `ZipTest/NativeGzip.lean` with:
  - Conformance tests: gzip and zlib at multiple compression levels, empty, single
    byte, large (124KB), incompressible, concatenated gzip streams
  - Auto-detect tests for all three formats
  - Error-case tests: empty input, truncated headers/trailers, bad magic, CRC32
    mismatch, Adler32 mismatch, wrong compression method, invalid block type,
    truncated stored block
- Security fix: enforced maxOutputSize on total concatenated gzip output (not just
  per-member)

**Decisions**:
- Gzip treats non-gzip trailing bytes after a valid member as end-of-stream
  (consistent with standard gzip implementations)
- Auto-detect can false-positive on raw DEFLATE streams that happen to look like
  zlib headers; this is a known inherent limitation
- Minimum 6 bytes required for zlib (2 header + 4 trailer minimum)

**Next**:
- Integration as alternative backend for ZIP/tar code paths
- Phase 3: DEFLATE spec formalization
- Full review of all Native/ code as cohesive unit
