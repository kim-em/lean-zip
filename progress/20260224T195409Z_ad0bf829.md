# Progress: Review — proof quality + deduplication in DecodeComplete.lean

**Date**: 2026-02-24T19:54 UTC
**Session type**: review (proof quality)
**Issue**: #223

## Accomplished

### Deliverable 1: Deduplicate bind-chain contradiction code
- Extracted `decodeLitLen_ge257_isReference` shared helper proving the reference
  chain always produces `.reference` when `sym_nat ≥ 257`
- `decodeLitLen_literal_inv` and `decodeLitLen_endOfBlock_inv` now call the
  shared helper instead of repeating ~22 lines of bind-chain case-splitting
- Net reduction: ~24 lines

### Deliverable 2: Proof quality pass on `decodeHuffman_complete`
- Hoisted `hsym_toNat` before the `cases sym_val` split — eliminates duplicate
  definitions in literal, endOfBlock, and reference cases
- Simplified `Option.some.inj` + `congrArg Prod.fst/snd` pattern in literal
  and reference cases using direct `simp` decomposition
- Compressed native↔spec table bridge proofs (`hnative_extra_eq`,
  `hnative_dextra_eq`) from 4 lines to 2 lines each by using `exact` instead
  of `have` + `omega`
- Simplified endOfBlock's equality extraction

### Deliverable 3: Import check
- Single import `Zip.Spec.DecodeCorrect` is necessary (provides all transitive deps)
- No `open` statements to check
- Pre-existing `hlen_bound` unused variable warning noted on `huffTree_decode_complete`
  theorem — cannot fix without changing theorem statement (constraint from plan)

## Key findings
- **Fin coercion matters for omega**: When compressing `have : T := f ⟨k, hk⟩`
  to `have := f ⟨k, hk⟩`, omega loses the type annotation and treats
  `Fin.val`-wrapped and bare expressions as distinct variables. Always keep
  explicit type annotations for hypotheses consumed by omega.

## Metrics
- Lines: 737 → 691 (−46)
- Sorry count: 0 → 0 (unchanged)
- Build: passes
- Tests: all pass
