# Progress Entry — 2026-02-24T14:16:25Z

**Session**: ad0bf829 (worker, implementation)
**Issue**: #190 — Prove computeCodeLengths_nonzero and complete deflateDynamic_spec — zero sorries
**Branch**: agent/ad0bf829
**Starting commit**: 4c26594
**Status**: Partial completion

## What was accomplished

### Deliverable 1: `computeCodeLengths_nonzero` + helpers (COMPLETED)

Added ~313 lines of helper lemmas and the main theorem in
`Zip/Spec/HuffmanEncode.lean`:

- `fixKraftList_nonzero`: preserves nonzero entries when maxBits > 0
- `foldl_set_pos_or_exists`: generalized positivity for foldl set ops
- `assignLengths_pos`: positive code length for symbols with nonzero freq
- `insertByWeight_mem`: iff characterization of membership after insertion
- `BuildTree.HasSym` (inductive): leaf symbol membership predicate
- `BuildTree.HasSym.in_depths`: HasSym → symbol appears in depths
- `buildHuffmanTree_HasSym`: tree construction preserves all symbols
- `buildHuffmanTree_isNode`: tree with ≥ 2 inputs returns a node
- `buildHuffmanTree_depths_ge_one`: all depths ≥ 1 with ≥ 2 inputs
- `buildHuffmanTree_leaf_in_depths`: wrapper for leaf → depths membership
- `computeCodeLengths_nonzero`: **main theorem** — symbols with nonzero
  frequency get nonzero code lengths

HuffmanEncode.lean now has zero sorries.

### Deliverable 2: `deflateDynamic_spec` proof (PARTIAL)

Expanded the single `sorry` into a structured proof skeleton in
`Zip/Spec/DeflateDynamicCorrect.lean` (+91 lines):

- Extracts intermediate values (tokens, freqs, code lengths)
- Proves `hlit_valid`, `hdist_valid` (ValidLengths for both tables)
- Proves length bounds (≥ 257/1, ≤ 288/32)
- Proves element bounds (∀ x ∈ lens, x ≤ 15)
- Handles the dist fixup case (all-zero → set index 0 to 1)
- Proves Kraft sum for `[1, 0, ..., 0]` via `decide`

**3 sorries remain** (each is a substantial sub-proof):
1. `encodeDynamicTrees litLens distLens` succeeds — needs
   `computeCodeLengths_nonzero` for CL codes + `encodeCLEntries` success
2. `encodeSymbols litLens distLens (tokensToSymbols tokens)` succeeds —
   needs bridge from `tokenFreqs` to `computeCodeLengths_nonzero`
3. `bytesToBits` decomposition — ~100 line BitWriter chain proof
   (follows `deflateFixedBlock_spec` pattern)

## Key proof patterns discovered

- `buildHuffmanTree_isNode`: proving the tree is a node (not leaf)
  when ≥ 2 input trees requires `by_cases` on rest list emptiness,
  not just length arithmetic
- `buildHuffmanTree_depths_ge_one`: starting depth 0 gives trivial
  `d ≥ 0` bound; need the `isNode` lemma to establish `d ≥ 1`
- `let` bindings in tactic mode are opaque to `rw`/`simp` — create
  explicit `have` copies for consistent variable matching
- Kraft sum for concrete lists (`List.replicate 30 0 |>.set 0 1`):
  `decide` works since `ValidLengths` has a `Decidable` instance

## Sorry count

- Start: 1 sorry (deflateDynamic_spec)
- End: 3 sorries (all in DeflateDynamicCorrect.lean, structured within
  the proof skeleton)
- Net: +2 sorries, but significantly more proof infrastructure in place
- HuffmanEncode.lean: 0 sorries (was 0, added new theorems)

## What remains

The 3 remaining sorries need new infrastructure:
- `tokenFreqs` properties (bridge symbol membership to frequency)
- `encodeCLEntries` success (bridge CL frequencies to CL code lengths)
- BitWriter chain correspondence proof

A new issue should be created for completing these.
