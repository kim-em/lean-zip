# Progress Entry

- **Date**: 2026-02-24 UTC
- **Session type**: Worker (implementation)
- **Issue**: #173 — Prove decode_suffix_invariant — DEFLATE decode ignores trailing bits

## What was accomplished

Proved `decode_go_suffix`: the spec-level DEFLATE `decode.go` function
ignores trailing bits appended to the input, provided the suffix length
is a multiple of 8 (needed for stored blocks' `alignToByte`).

All three deliverables from the issue are complete:

1. **`readBitsLSB_append`** — reading n bits from `bits ++ suffix` gives
   the same value with `rest ++ suffix` as remainder.

2. **`decodeSymbols_append`** (and its prerequisite `decodeLitLen_append`) —
   Huffman symbol decoding is suffix-invariant, given `ValidLengths` for
   both lit/len and distance code lengths. Also proved `decode_some_append`
   and `decode_suffix` in HuffmanTheorems.lean, and
   `allCodes_swapped_prefix_free` for prefix-free table construction.

3. **`decode_go_suffix`** — the top-level theorem. Handles stored blocks
   (via `decodeStored_append`), fixed Huffman (using existing
   `fixedLitLengths_valid`/`fixedDistLengths_valid`), and dynamic Huffman
   (via `decodeDynamicTables_append` + `decodeDynamicTables_valid_lit`/
   `_valid_dist`). Reserved block type (≥3) is a contradiction.

## Key proof patterns discovered

- **`List.replicate 19 0` expansion**: After `unfold decodeDynamicTables`,
  `List.replicate 19 0` expands to the 19-element literal `[0,...,0]` in
  hypotheses. `cases hcl : readCLLengths ... (List.replicate 19 0) ...`
  produces `hcl` with the symbolic form. Fix: create a literal-form alias
  `have hcl' : ... [0,0,...,0] ... = result := hcl` (definitionally equal).

- **Suffix proofs require separate handling of `h` and `⊢`**: Unlike
  fuel-independence proofs where `simp only [hx] at h ⊢` processes both
  sides (same function call), suffix proofs have different arguments
  (`bits` vs `bits ++ suffix`). Process `h` with `simp only [hx, bind,
  Option.bind]`, then transform `⊢` with `rw [foo_append ...]` followed
  by `simp only [bind, Option.bind]`.

- **`if` branching with `by_cases`**: For `if (bfinal == 1) = true then
  ... else ...` appearing in both `h` and `⊢`, use `by_cases hbf1 :
  (bfinal == 1) = true` then `rw [if_pos/if_neg hbf1] at h ⊢`.

## Sorry count

- Start: 4 (3 in DeflateFixedCorrect, 1 in InflateCorrect)
- End: 4 (unchanged — no new sorries)

## What remains

Issue #173 is fully resolved. The `decode_go_suffix` theorem unblocks
the roundtrip proofs (`inflate_deflateFixed`, `inflate_deflateLazy`,
`inflate_deflateDynamic`) which need to show that extra padding bits
in the bitstream don't affect decode output.
