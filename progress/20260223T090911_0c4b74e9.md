# Progress: Spec-level Huffman code length computation

- **Date**: 2026-02-23T09:09 UTC
- **Session**: 0c4b74e9 (worker, implementation)
- **Issue**: #62 — Spec-level Huffman code length computation from symbol frequencies

## What was accomplished

Created `Zip/Spec/HuffmanEncode.lean` with the standard Huffman tree
construction algorithm for computing optimal code lengths from symbol
frequencies. This is the encoding direction needed for dynamic Huffman
blocks (DEFLATE Levels 5-9).

### Definitions
- `BuildTree` — weighted binary tree for Huffman construction
- `insertByWeight` — sorted insertion by weight
- `buildHuffmanTree` — standard greedy algorithm with termination proof
- `BuildTree.depths` — extract (symbol, depth) pairs
- `assignLengths` — place depths into symbol-indexed list
- `computeCodeLengths` — full pipeline: freqs → filter → sort → tree → depths → cap → assign
- `kraftSum` — Kraft sum definition for proof infrastructure

### Proved theorems
- `insertByWeight_length` — key termination lemma
- `assignLengths_length`, `computeCodeLengths_length` — output size
- `BuildTree.depths_ne_nil`, `BuildTree.depths_ge` — structural properties
- `foldl_set_length`, `foldl_set_bounded` — fold invariants
- `assignLengths_bounded` — output values ≤ bound
- `validLengths_replicate_zero` — empty case of ValidLengths
- `kraftSum_init`, `kraftSum_append` — Kraft sum algebra
- **`BuildTree.kraft_eq`** — binary trees satisfy Kraft equality (the
  fundamental property connecting tree structure to code validity)

### Sorry'd (2 actual sorry, +2 sorry count)
- `validLengths_single` — Kraft inequality for single-symbol case
  (needs connecting `assignLengths` output to foldl-based Kraft sum)
- `computeCodeLengths_valid` — general multi-symbol case
  (`BuildTree.kraft_eq` is proved; remaining work is plumbing through
  `assignLengths` and depth capping to `ValidLengths`)

## Decisions
- Created a new file `HuffmanEncode.lean` rather than extending
  `Huffman.lean` — keeps encoding concerns separate from decoding
- Used `BuildTree` name (not `HuffTree`) to avoid conflict with
  `Zip.Native.HuffTree` used for decoding
- `computeCodeLengths` caps depths with `min d maxBits` rather than
  redistributing — sufficient for typical DEFLATE inputs where tree
  depth ≤ 9, well under maxBits = 15

## What remains
- Prove the Kraft inequality plumbing in `computeCodeLengths_valid`
  (key lemma `BuildTree.kraft_eq` is done; need to connect through
  `assignLengths` and depth capping)
- The next step in the dynamic Huffman pipeline is RLE encoding of
  code lengths (issue #66)

## Sorry count
- Start: 2 (both in LZ77NativeCorrect.lean)
- End: 4 (2 existing + 2 new in HuffmanEncode.lean)
- Delta: +2
