# Partial: endPos_ge padding hypothesis + deflateRaw_pad

**Session**: 9f94d6fe (feature)
**Issue**: #293
**Branch**: agent/9f94d6fe

## What changed

Added encoder padding decomposition theorem and restructured `inflateRaw_endPos_ge`
to accept the padding hypothesis. Sorry reduced from "the entire endPos_ge proof
body" to a single `remaining.length < 8` gap.

### Key theorems added

**DeflateRoundtrip.lean**:
- `deflateRaw_pad`: for all compression levels, `bytesToBits (deflateRaw data level) =
  contentBits ++ padding` with `padding.length < 8`. Dispatches to per-level specs
  (stored: padding=[], fixed/lazy: replicate padding, dynamic: replicate padding).

**GzipCorrect.lean**:
- `inflateLoop_complete_ext` extended: now tracks `remaining : List Bool` with
  `br_final.toBits = remaining` in its conclusion (all 6 cases updated)
- `inflateRaw_endPos_ge` restructured: takes `hpad` hypothesis (encoder padding
  decomposition) in addition to `hspec` (spec decode success)
- `inflateRaw_endPos_eq` updated: passes `hpad` through

**ZlibCorrect.lean**:
- Updated call site to pass `deflateRaw_pad` to `inflateRaw_endPos_eq`

### Remaining sorry (1)

`remaining.length < 8` in `inflateRaw_endPos_ge` (GzipCorrect.lean:1230).

The proof has:
- `remaining` from `inflateLoop_complete_ext` (= `br_final.toBits`)
- `hdecomp : bytesToBits deflated = contentBits ++ padding`
- `hpadlen : padding.length < 8`
- Everything else: endPos determinism, data preservation, alignToByte bridge

The missing link: a formal proof that `remaining = padding` (or `remaining.length ≤ padding.length`).
This requires a suffix-remaining induction showing that when `decode.go` processes
`contentBits ++ padding`, the completeness chain leaves exactly `padding` as
the native BitReader's remaining bits.

## Approach notes for future sessions

Three viable approaches to fill the sorry:

1. **decode_go_with_rest** (~200 lines): Define a variant of `decode.go` that
   returns `Option (List UInt8 × List Bool)` (result + remaining bits), prove
   equivalence with `decode.go`, then prove `remaining = padding` directly.

2. **Suffix-remaining induction** (~150 lines): Prove by induction on spec fuel
   that if `decode.go (bits ++ suffix) acc fuel = some result` and
   `decode.go bits acc fuel = some result`, then the completeness proof on
   `bits ++ suffix` yields `remaining = suffix`. Uses `_append` lemmas from
   DeflateSuffix.lean (`readBitsLSB_append`, `decodeSymbols_append`, etc.).

3. **Direct BitReader arithmetic** (~100 lines): Avoid the suffix connection
   entirely. Instead, prove that `br_final.pos * 8 + br_final.bitOff ≥
   pfx.size * 8 + contentBits.length` by strengthening `inflateLoop_complete_ext`
   to track cumulative bit consumption. Combined with
   `contentBits.length = deflated.size * 8 - padding.length` and `padding.length < 8`,
   this gives `remaining.length ≤ padding.length < 8`.

Approach 3 is likely the most economical. The key helper lemma needed:
each `_complete` step in the induction advances `pos * 8 + bitOff` by exactly
the number of bits consumed by the corresponding spec function.

## Pre-existing sorry

`DeflateFixedCorrect.lean:409` — not from this session.
