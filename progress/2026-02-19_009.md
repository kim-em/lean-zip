# 2026-02-19: Implementation — Huffman codeFor_injective + canonical_prefix_free

**Type**: implementation
**Phase**: Phase 3 (verified decompressor) — in progress
**Sorry count**: 2 → 2 (same count, but sorry's are now in smaller helpers)

**Accomplished**:
- `codeFor_injective` structurally complete. Proof chain: `codeFor_spec`
  extracts structural info → `natToBits_length` shows lengths equal →
  `natToBits_injective` shows code values equal → `offset_of_lt` gives
  contradiction if s₁ ≠ s₂. Depends on sorry'd `code_value_bound`.
- `canonical_prefix_free` same-length case proved: same-length prefix implies
  equality → `codeFor_injective` gives s₁ = s₂ → contradicts s₁ ≠ s₂.
- Rewrote `natToBits` from accumulator-based to simple recursion for easier
  inductive reasoning. Proved `natToBits_length`, `natToBits_eq_iff`,
  `natToBits_injective`.
- Proved Kraft inequality helpers: `kraft_ge_count`, `filter_ne_zero_filter_eq`,
  `foldl_add_init`, `count_le_pow_of_validLengths`.
- Proved `count_foldl_mono`, `offset_of_lt`, `codeFor_spec`.

**Issues fixed**:
- `cases` on `(x == len)` already reduces `ite` — subsequent `simp` makes
  no progress. Solution: use the result directly.
- `apply ih n (s₂-1)` with bullets: Lean assigns goals in non-obvious order.
  Solution: use `exact ih ... (by omega) hlen₁' (by omega) (by omega) _`.
- omega fails when `hs₂ : s₂ ≤ (x :: xs).length` not simplified to involve
  `xs.length`. Solution: `simp only [List.length_cons] at hs₁ hs₂`.

**Remaining sorry's**:
- `Zip/Spec/Huffman.lean:222` — `code_value_bound` (nc[len] + offset < 2^len)
- `Zip/Spec/Huffman.lean:390` — `canonical_prefix_free` different-length case

Both require the nextCodes recurrence invariant: nc[b] + count[b] ≤ 2^b.
Proof strategy documented in PLAN.md.

**Additional progress (continuation session)**:
- Decomposed `code_value_bound` into `nextCodes_plus_count_le` (sorry'd,
  minimal core) + offset bound (proved via `offset_of_lt`).
- Assembly: `nc + offset < nc + totalCount ≤ 2^len` via omega.
- Documented proof strategy for `nextCodes_plus_count_le` in PLAN.md:
  telescoping invariant `S(b)*2^(maxBits-b) + kraftTail(b+1) ≤ 2^maxBits`.
- Discovered: `by_contra`, `push_neg`, `set` are Mathlib-only.

**Sorry locations** (final):
- `Zip/Spec/Huffman.lean:230` — `nextCodes_plus_count_le`
- `Zip/Spec/Huffman.lean:419` — `canonical_prefix_free` different-length case

**Next**: Prove nextCodes_plus_count_le (see PLAN.md for detailed steps).
