# Progress: Prove emitTokensWithCodes_spec

- **Date**: 2026-02-24T03:46 UTC
- **Session**: 98d23d6c (worker, implementation)
- **Issue**: #121

## Accomplished

All three deliverables completed:

1. **`encodeSymbol_canonicalCodes_eq`** — Generalized bridge theorem proving
   that when `encodeSymbol` on `allCodes`-derived tables returns a codeword
   for symbol `s`, it matches `natToBits` of the corresponding
   `canonicalCodes` entry. This generalizes `encodeSymbol_litTable_eq` /
   `encodeSymbol_distTable_eq` from DeflateFixedCorrect.lean to work with
   arbitrary `canonicalCodes`-produced tables.

2. **`emitTokensWithCodes_spec`** (+ `_go` helper) — Proves that native
   `emitTokensWithCodes` produces the same bit sequence as spec
   `encodeSymbols` when code arrays are produced by `canonicalCodes` from
   valid code lengths. Mirrors `emitTokens_spec_go` but uses the generalized
   `encodeSymbol_canonicalCodes_eq` instead of fixed-table lemmas.

3. **Source layout and imports** — New file `Zip/Spec/DeflateDynamicCorrect.lean`
   imported in `Zip.lean`, source layout table updated in `.claude/CLAUDE.md`.

## Side changes

- Made `findLengthCode_agree` and `findDistCode_agree` `protected` (previously
  `private`) in DeflateFixedCorrect.lean so they can be reused from the new
  correctness file.

## Proof patterns

- **UInt8 positivity from Nat membership**: When `hne0 : (lengths.toList.map
  UInt8.toNat)[s] ≠ 0` and you need `lengths[s] > 0` (UInt8), first establish
  `hs_i : (list.map ...)[s] = lengths[s].toNat` and `hne0_nat := hs_i ▸ hne0`,
  then `simp only [GT.gt, UInt8.lt_iff_toNat_lt, UInt8.toNat_ofNat]; omega`.
  Plain `omega` alone can't bridge UInt8 comparison to Nat.

- **List Nat ↔ Array UInt8 roundtrip**: For `ValidLengths litLens 15`, prove
  `litLens = (litLens.toArray.map Nat.toUInt8).toList.map UInt8.toNat` via
  `simp only [Array.toList_map, List.map_map]; symm` then
  `rw [List.map_congr_left ...]` showing each element roundtrips (all ≤ 15 < 256)
  then `simp` to close `List.map (fun n => n) l = l`.

## Sorry count

- Before: 8 (5 DeflateFixedCorrect, 3 DeflateEncodeDynamic)
- After: 8 (unchanged — this issue adds new theorems, no sorry reduction)

## What remains

The `emitTokensWithCodes_spec` theorem is now on the critical path for
`inflate_deflateDynamic`. Next steps (for future issues):
- `deflateDynamic_spec` combining `encodeDynamicTrees_decodeDynamicTables` +
  `emitTokensWithCodes_spec` for full Level 5 bitstream correspondence
- `inflate_deflateDynamic` end-to-end roundtrip theorem
