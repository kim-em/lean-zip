# Progress: Native stored-block roundtrip

- **Date**: 2026-02-23 08:49 UTC
- **Session**: worker (implementation)
- **Issue**: #52 â€” Native Level 0 roundtrip: inflate (deflateStored data) = .ok data
- **Branch**: agent/e2e595ec
- **Starting commit**: 20ef7a0
- **Starting sorry count**: 4

## What was accomplished

Created `Zip/Spec/DeflateStoredCorrect.lean` (~320 lines) with:

### Definitions
- `deflateStoredPure`: Pure recursive DEFLATE stored-block encoder for proof
  purposes. Encodes data as stored blocks (at most 65535 bytes each), with
  BFINAL=1 on the last block.

### Proved theorems
- `readBits_1_at_0`: Reading 1 bit at bitOff 0 returns the LSB
- `readBits_2_at_1`: Reading 2 bits at bitOff 1 returns bits 1-2 (bv_decide)
- `readUInt16LE_at_aligned`: Reading UInt16LE at byte-aligned position
- `uint16_le_roundtrip`: LE encoding/decoding roundtrip for UInt16 (bv_decide)
- `uint16_xor_complement`: a ^^^ (a ^^^ 0xFFFF) = 0xFFFF (bv_decide)
- `readBytes_at_aligned`: Reading bytes at byte-aligned position
- `readUInt16LE_align`: readUInt16LE with non-zero bitOff aligns first
- `decodeStored_align`: decodeStored with non-zero bitOff aligns first
- `decodeStored_on_block`: decodeStored on properly formatted stored block data
  succeeds and returns the block data
- `inflateLoop_final_stored`: inflateLoop correctly processes a single final
  stored block (composing all the above)

### Sorry'd theorems (3)
- `fromLengths_fixedLit_ok`: Array.any is kernel-opaque, preventing decide/rfl.
  Approaches tried: rfl (max recursion), decide (Array.any opaque), manual
  unfold + List conversion (Kraft inequality computation doesn't reduce).
- `fromLengths_fixedDist_ok`: Same issue.
- `inflate_deflateStoredPure`: Needs fromLengths proofs + multi-block induction.
  The inflateLoop_final_stored theorem provides the key single-block case.

## Key proof patterns discovered

- **`generalize` before `bv_decide`**: When `bv_decide` abstracts the same
  expression (e.g., `data[pos]`) as two different opaque variables, use
  `generalize data[pos].toUInt32 = x` first to unify them.
- **`Bool.false_eq_true` for `if false = true`**: When simp leaves
  `if false = true then ... else ...`, add `Bool.false_eq_true` to reduce it.
- **Alignment lemma pattern**: Prove `readUInt16LE_align` (readUInt16LE with
  non-zero bitOff = readUInt16LE after alignment) as a reusable lemma, then
  derive `decodeStored_align` from it.

## Sorry count
- Start: 4
- End: 7 (net +3, all in new file with theorem statements ready for proofs)

## What remains
- Prove `fromLengths_fixedLit_ok` and `fromLengths_fixedDist_ok`: Need a way to
  evaluate `Array.any` in proofs. Options: (1) add `Array.any_toList_any` bridge
  lemma to ZipForStd, (2) prove via List reduction, (3) investigate if newer
  Lean versions make Array.any reducible.
- Prove `inflate_deflateStoredPure`: Once fromLengths proofs exist, the proof
  structure is: unfold inflate/inflateRaw, use fromLengths for tree construction,
  then induction on block count using inflateLoop_final_stored for each block.
