# Progress: Stored block compression expansion bound

**Date**: 2026-02-25T05:06Z
**Session**: 1eaaf331 (feature)
**Issue**: #275

## Accomplished

### Deliverable 1: `deflateStoredPure_size` — exact output size (DONE)

Proved that `deflateStoredPure` output size is exactly:
```
data.size + 5 * numStoredBlocks data.size
```
where `numStoredBlocks n = (n - 1) / 65535 + 1`.

The proof uses well-founded recursion on `data.size - pos`, decomposing via
`deflateStoredPure_eq_final` and `deflateStoredPure_eq_nonfinal`, with `omega`
closing the arithmetic goals. The formula `(n-1)/65535 + 1` correctly handles
all cases including n=0 (empty input still produces one 5-byte block).

Note: the issue plan suggested `(n + 65534) / 65535` for the number of blocks,
but this gives 0 for n=0 while the function produces 1 block. Using
`(n-1)/65535 + 1` (which in Nat gives 1 for n=0) is the correct formula.

### Deliverable 2: `deflateStoredPure_size_bound` — expansion bound (DONE)

Proved the upper bound:
```
(deflateStoredPure data 0).size ≤ data.size + 5 + data.size / 13107
```

The proof decomposes `65535 = 13107 * 5`, uses `Nat.div_div_eq_div_mul` to
factor the division, then `Nat.mul_div_le` and `Nat.div_le_div_right` to
chain the bound.

### Deliverable 3: `deflateRaw_size_ge_stored` — stored blocks worst case (SKIPPED)

Investigated and determined the theorem as stated is **false**. Fixed Huffman
encoding uses 9-bit codes for byte values 144-255, meaning worst-case fixed
Huffman output is ~1.125× input size, exceeding stored block output (~1.00008×).
The implementation's `deflateFixed`/`deflateLazy`/`deflateDynamic` do not fall
back to stored blocks for incompressible data, so higher compression levels CAN
produce larger output than level 0.

A correct version would need to bound each compression strategy's worst case
independently, which requires reasoning about Huffman tree structure and LZ77
token expansion — a substantially larger proof effort.

## Decisions

- Used `numStoredBlocks` as a named helper def for clarity
- Chose well-founded recursion (`termination_by data.size - pos`) over
  `Nat.strongRecOn` to avoid maxRecDepth issues with the induction hypothesis
- Formula `(n-1)/65535 + 1` over `(n+65534)/65535` for correctness at n=0

## Sorry count

Before: 3 (1 GzipCorrect, 2 ZlibCorrect)
After: 3 (unchanged — no new sorries introduced)
