# Progress: Deep review of DynamicTreesCorrect.lean

**Date**: 2026-02-23T05:38Z
**Session**: 119a78f3 (worker, review)
**Issue**: #18

## Accomplished

Line-by-line review of `Zip/Spec/DynamicTreesCorrect.lean` (927 lines),
the most complex proof file in the codebase. Applied systematic cleanup:

### Dead code removal
- Removed unused `take_map_getLast` helper (13 lines) — defined but
  never referenced anywhere. `extract_map_getLast_eq` handles the same
  use case and is the one actually used.

### Proof minimization
- Combined sequential `rw` calls on the same hypothesis: `rw [a] at h;
  rw [b] at h; rw [c] at h` → `rw [a, b, c] at h` (6 sites across
  sym==16/17/18 branches)
- Replaced `simp [...] at this ⊢; exact this` with `simpa [...] using
  this` (2 sites)
- Simplified `fromLengths_valid` inner proof: combined `rw` steps and
  replaced `have/simp/exact` with `simpa using`
- Combined `rw`+`simp only []` pairs into single `simp only` calls
  for spec threading in `decodeDynamicTrees_correct` (3 sites)
- Combined `extract_map_getLast_eq` proof steps

### Comment cleanup
- Removed 25+ verbose comments that restated what the code does
  (e.g. "-- Native: readBits 3", "-- Apply IH", "-- Step 6:
  decodeCLSymbols") without adding insight
- Kept structural comments (-- sym < 16, -- sym == 16, etc.) that
  aid navigation

### Deduplication
- Extracted `have hle : idx ≤ codeLengths.size := by omega` once in
  the common header of `decodeCLSymbols_correct`, replacing 4 inline
  `show idx ≤ codeLengths.size from by omega` occurrences

### Results
- 927 → 824 lines (103-line reduction, 11%)
- All 15 theorem/lemma statements preserved unchanged
- Zero sorries (unchanged)
- Library builds clean; test executable has pre-existing linker issue
  (missing libzstd system library, not related to this change)

## Decisions
- Did NOT extract a common lemma for the sym==17/18 branches despite
  similar structure. The differences in bit widths (3 vs 7) and repeat
  offsets (3 vs 11) make parameterization awkward — the resulting lemma
  would need many parameters and wouldn't be shorter overall.
- Did NOT inline `hsym_nat : sym.toNat < 16 := hsym_lt` and similar
  UInt16→Nat coercions. While these may be definitional equalities,
  removing them risks breaking the proof if the simp context changes.
