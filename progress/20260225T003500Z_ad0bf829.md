# Session ad0bf829 — ByteArray.set! lemmas + in-place write roundtrips

**Type**: feature
**Issue**: #258
**PR**: #260

## What was done

1. **Added ByteArray.set! interaction lemmas** to `ZipForStd/ByteArray.lean`:
   - `getElem!_eq_data_getElem!` — bridge lemma connecting ByteArray getElem! to Array getElem!
   - `size_set!` — ByteArray.set! preserves size
   - `getElem!_set!_self` — reading at the written index returns the new value
   - `getElem!_set!_ne` — reading at a different index is unaffected

2. **Proved in-place write roundtrips** in `Zip/Spec/BinaryCorrect.lean`:
   - `readUInt16LE_writeUInt16LEAt` — 2-byte roundtrip
   - `readUInt32LE_writeUInt32LEAt` — 4-byte roundtrip (uses have-based extraction for each byte)
   - `readUInt64LE_writeUInt64LEAt` — 8-byte roundtrip (composes UInt32 proofs)

3. **Proved non-interference lemma**:
   - `readUInt32LE_writeUInt32LEAt_ne` — writing at one offset doesn't affect reads at non-overlapping offsets

4. **Proved size preservation lemmas**:
   - `writeUInt16LEAt_size`, `writeUInt32LEAt_size`, `writeUInt64LEAt_size`

## Key patterns

- ByteArray.getElem! ≠ Array.getElem! — needed a bridge lemma (`getElem!_eq_data_getElem!`) to convert between them
- ByteArray.set! unfolds to `{ data := data.data.setIfInBounds i v }`, not `⟨data.data.set! i v⟩` — but `show` can convert the goal
- For the UInt32 roundtrip, `rw` on let-bound `readUInt32LE` didn't fire on all bindings simultaneously — solved by using explicit `have` statements for each byte extraction

## Sorries: 0 new, 10 pre-existing (unchanged)

## Files modified
- `ZipForStd/ByteArray.lean` — +30 lines (set! lemmas)
- `Zip/Spec/BinaryCorrect.lean` — +109 lines (roundtrips, non-interference, size)
