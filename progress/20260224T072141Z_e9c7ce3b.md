# Progress: Prove decodeCLSymbols_complete + split DynamicTreesCorrect

**Date**: 2026-02-24T07:21Z
**Session**: Worker (implementation)
**Issue**: #157

## What was accomplished

1. **Proved `decodeCLSymbols_complete`** — the completeness direction for
   CL symbol decoding (spec succeeds → native succeeds). This is the
   reverse direction of the existing `decodeCLSymbols_correct`.

2. **Split `DynamicTreesCorrect.lean`** (1173 lines → 819 + 367):
   - `DynamicTreesCorrect.lean` (819 lines): forward proofs, helpers,
     main theorem `decodeDynamicTrees_correct`
   - `DynamicTreesComplete.lean` (367 lines): completeness proofs
     `readCLCodeLengths_complete` and `decodeCLSymbols_complete`

3. **Changed helper visibility** from `private` to public for helpers
   shared across files: `extract_set_map_append`, `extract_map_getLast_eq`,
   `fillEntries_size`, `fillEntries_snd`, `fillEntries_extract`.

## Key proof patterns discovered

- **`Nat.mod_eq_of_lt` for `rep.toUInt32.toNat = rep`**: omega cannot
  reason about `%` with non-constant modulus. Use
  `Nat.mod_eq_of_lt (by omega)` when the bound is available (e.g.,
  `rep < 2^n` from `readBitsLSB_bound`).

- **Nat↔UInt16 beq bridging**: When `hsym_ne16 : ¬(sym == 16) = true`
  (Nat beq) and `h : sym.toUInt16 = 16` (UInt16 eq), bridge via
  `congrArg UInt16.toNat h` + `rw [hsym_toNat]` to get `sym = 16`,
  then `beq_iff_eq.mpr` to get back to Nat beq contradiction.

- **`guard`/`pure`/`Pure.pure` linter false positives**: The unused simp
  args linter reports these as unused, but removing them breaks the proof.
  Use `set_option linter.unusedSimpArgs false in` to suppress.

## Sorry count

- Start: 9
- End: 8
- Delta: -1 (proved `decodeCLSymbols_complete`)

## What remains

The completeness proofs are building blocks — they aren't used by the
main `decodeDynamicTrees_correct` theorem yet. A future
`decodeDynamicTrees_complete` theorem would compose them to prove the
full dynamic tree decode completeness.
