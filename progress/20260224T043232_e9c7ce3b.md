# Progress: Prove readBits_complete

- **Date**: 2026-02-24T04:32 UTC
- **Session**: e9c7ce3b (worker, implementation)
- **Issue**: #120 — Prove readBits_complete (BitReader reverse-direction completeness)
- **Branch**: agent/e9c7ce3b
- **Starting commit**: a94f4ff
- **Starting sorry count**: 13

## Completed

All deliverables from #120 were completed:

1. **`toBits_nonempty_pos`** — helper lemma: non-empty `toBits` implies `pos < data.size`
2. **`readBit_complete`** — reverse direction for single-bit reads, including `hpos` invariant preservation
3. **`readBits_go_complete`** — generalized loop invariant for the reverse direction, using induction on `k`
4. **`readBits_complete`** — top-level wrapper, fills the sorry from #118

## Key decisions

- **Reformulated `readBits_go_complete` conclusion**: Instead of embedding the computed UInt32 value
  `⟨acc.toNat + specVal * 2^shift⟩` directly in the `Except.ok` result (which creates `BitVec.ofNat`
  wrapping that's hard to rewrite), used `∃ result br', ... ∧ result.toNat = acc.toNat + specVal * 2^shift`.
  This separates the Nat arithmetic from the UInt32 representation, making the proof much cleaner.

- **Used `grind` for multiplicative Nat arithmetic**: `omega` can't handle `v * 2 * 2^shift = v * (2^shift * 2)`
  (non-linear). `grind` handles this algebraic identity cleanly.

## Proof patterns

- **`List.cons.inj`** for extracting head/tail equality from `a :: rest1 = b :: rest2`
- **`congrArg (BitVec.ofNat 32)` for lifting Nat equality to UInt32**: When `x = y : Nat`,
  `congrArg (BitVec.ofNat 32) h` gives `BitVec.ofNat 32 x = BitVec.ofNat 32 y`, which suffices
  for UInt32 equality since UInt32 = BitVec 32.

## Sorry count

- Start: 13
- End: 12 (net -1)
- BitstreamCorrect.lean: 3 → 2 (readBits_complete filled; readUInt16LE_complete and readBytes_complete remain)

## What remains

The remaining 2 sorries in BitstreamCorrect.lean (`readUInt16LE_complete`, `readBytes_complete`)
are out of scope for this issue but are needed for the broader inflate_complete effort.
