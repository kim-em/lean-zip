# 2026-02-22: Implementation — decodeHuffman_correct length/distance case

**Session type**: Implementation
**Starting commit**: `2694d98` | **Sorry count**: 2 → 2 (unchanged)

### Accomplished

Completed the length/distance case of `decodeHuffman_correct`, the third
and final symbol type. All three cases (literal, end-of-block,
length/distance) are now proved.

Key additions to `InflateCorrect.lean` (+227 lines):
- **Table correspondence lemmas**: `lengthBase_eq`, `lengthExtra_eq`,
  `distBase_eq`, `distExtra_eq` — proved by `decide` over `Fin 29`/`Fin 30`
- **Bound lemmas**: `lengthExtra_le_32`, `distExtra_le_32` (for readBits),
  `spec_distBase_pos` (for distance guard)
- **`copyLoop_eq_ofFn`**: Cleanly stated helper for forIn ↔ List.ofFn
  correspondence (sorry — the remaining gap)
- **Full length/distance proof**: 8-step monadic case splitting, spec-level
  correspondence chain, decodeLitLen evaluation, resolveLZ77 guard conditions

### Decisions

- Factored the copy loop correspondence into a standalone `copyLoop_eq_ofFn`
  lemma rather than leaving an inline sorry. This makes the proof structure
  cleaner and the remaining gap well-defined.
- Used `getElem!_pos` + `getElem?_pos` pattern to bridge `c[i]!` vs `c[i]`
  in getElem? proofs.

### Remaining

- `copyLoop_eq_ofFn` (sorry): prove forIn copy loop = List.ofFn
- `inflate_correct` (sorry): main theorem (block loop correspondence)
