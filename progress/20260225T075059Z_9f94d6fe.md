# Review: proof quality in BinaryCorrect.lean + Adler32.lean + Crc32.lean

**Date**: 2025-02-25T07:50Z
**Session type**: review
**Issue**: #270

## What was accomplished

Reviewed all three files (BinaryCorrect.lean 321 lines, Adler32.lean 93 lines,
Crc32.lean 67 lines) against the standard review checklist.

### BinaryCorrect.lean improvements (321→300 lines)

1. **`readUInt32LE_writeUInt32LEAt_ne`**: Replaced 16 explicit `getElem!_set!_ne`
   rewrites with `repeat rw` — same semantics, 1 line instead of 16.

2. **`writeUInt{16,32}LEAt_size`**: Simplified from `unfold + rw` chains to
   `simp [writeUInt*LEAt, ByteArray.size_set!]`.

3. **Added `@[simp]` to `writeUInt{16,32,64}LEAt_size`**: Consistent with the
   existing `@[simp]` on `writeUInt{16,32}LE_size`. Enables `by simp; omega`
   downstream instead of `by rw [writeUInt32LEAt_size]; omega`.

4. **`writeUInt64LEAt_size`**: Simplified to use `simp` with the newly `@[simp]`
   lemmas instead of manual `unfold + rw`.

5. **`readUInt16LE_writeUInt16LEAt`**: Removed unused named `have hs` (left over
   from a previous proof structure), replaced with anonymous `have`.

6. **`readUInt64LE_writeUInt64LEAt`**: Updated to use `by simp; omega` instead of
   `by rw [writeUInt32LEAt_size]; omega`.

### Adler32.lean — no changes needed

Clean, well-structured. `updateList_append` proven via `List.foldl_append`,
bounds theorems properly structured with `Valid` predicate. No dead code.

### Crc32.lean — no changes needed

`mkTable` and `crcByteTable` are NOT dead code — they're used in
`Zip/Native/Crc32.lean` for the table-driven implementation and its
correctness proof (`crcByteTable_eq_crcByte`).

## Review findings (no action needed)

- `ba4_getElem!_*` are only used within BinaryCorrect.lean itself, but were
  deliberately made public (per progress/20260224T212351Z_ad0bf829.md) for
  cross-file use. Leaving them public.
- `readUInt32LE_append3_{mid,right}`, `readUInt32BE_{bytes,append_right}`,
  `getElem!_append3_left` are only used internally — they're infrastructure
  for future proofs (gzip/zlib framing). Keeping them.
- The verbose `have` blocks in `readUInt32LE_writeUInt32LEAt` are necessary:
  `rw` can't distinguish between 4 `getElem!` occurrences in the goal without
  explicit type annotations.

## Sorry count

Unchanged at 4 (2 GzipCorrect + 2 ZlibCorrect). Reviewed files: 0 sorrys.

## Verification

- `lake build`: passes (182 jobs)
- `lake exe test`: all tests passed
