# Progress: Prove lz77Greedy_size_le + explore emitTokens_spec

- **Date**: 2026-02-24 09:49 UTC
- **Session type**: Worker (issue #76)
- **Branch**: `agent/077a7f32`

## What was accomplished

### Required deliverables (completed)

1. **Proved `lz77Greedy_size_le`** — removed sorry from DeflateFixedCorrect.lean.
   Shows `(lz77Greedy data windowSize).size ≤ data.size` (worst case: every
   byte is a literal).

2. **Added helper lemmas to LZ77NativeCorrect.lean**:
   - `trailing_length`: `(trailing data pos).length ≤ data.size - pos`
   - `mainLoop_length`: `(mainLoop data ws hs ht hv pos).length ≤ data.size - pos`
   - `length_cons_le_of_advance`: arithmetic helper for the cons + advance pattern

3. **Fixed stale comment** on `tokensToSymbols_encodable` (removed "(which has sorry)").

### Stretch goal (assessed, not completed)

`emitTokens_spec` requires a `canonicalCodes ↔ allCodes` correspondence
proof — a loop invariant for `canonicalCodes.go` showing:
```
∀ len, nextCode[len] = initialNC[len] + count(j < i, lengths[j] = len)
```
This is a substantial piece of infrastructure that was correctly identified
in the existing sorry documentation. The proof would need:
- Loop invariant for `canonicalCodes.go` (Array update + count correspondence)
- Bridge from Array (UInt16 × UInt8) to List (Nat × Codeword)
- Connecting `natToBits` with `codeFor`

Both `canonicalCodes` and `allCodes` use the same `countLengths`/`nextCodes`
building blocks, so the correspondence definitely holds. Suitable for a
dedicated future issue.

## Key proof patterns discovered

- **`exact` vs `have :=` for wildcard resolution**: `exact f _ _ _` does
  goal-directed elaboration (wildcards resolved from goal type), while
  `have := f _ _ _` elaborates independently and can't resolve wildcards
  for complex expressions like hash table states. Solution: extract
  arithmetic helpers and use `exact` with the helper + recursive call.

- **`length_cons_le_of_advance` pattern**: For recursive functions that
  emit one element per iteration and advance by ≥ 1, the arithmetic
  `n ≤ s - (pos + k) → k ≥ 1 → pos + k ≤ s → n + 1 ≤ s - pos` is
  cleanly handled by a separate helper rather than fighting omega with
  expanded let bindings.

## Sorry count

- Start: 15 (6 in DeflateFixedCorrect, 4 in HuffmanEncode, 5 in DeflateStoredCorrect)
- End: 13 (4 in DeflateFixedCorrect, 4 in HuffmanEncode, 5 in DeflateStoredCorrect)
- Delta: -2

## Files changed

- `Zip/Spec/LZ77NativeCorrect.lean` — added 3 theorems (+43 lines)
- `Zip/Spec/DeflateFixedCorrect.lean` — proved `lz77Greedy_size_le`, fixed comment (+9/-4 lines)
