# Progress: Skills Update for Phase 4+ Proof Patterns

- **Date**: 2026-02-25T04:48Z
- **Session**: 1eaaf331 (meditate)
- **Issue**: #254

## What was done

First meditate session after 113+ merged PRs. Surveyed the last 20 progress
entries to identify recurring struggle patterns, then updated 4 skills with
concrete guidance grounded in real codebase examples.

### Skills updated

1. **lean-monad-proofs** (+78 lines): Added two new sections:
   - Multi-guard Except unfolding for framing proofs (the `unless` desugaring,
     nested `match` pattern for long guard chains, extracting witnesses through
     guards)
   - `dsimp` vs `simp` after `unfold` on recursive functions (critical: `simp`
     loops, `dsimp` is safe)

2. **lean-array-list** (+43 lines): Added ByteArray concatenation indexing
   section documenting the `getElem!_append_left/right` chain for two-part and
   three-part concatenation, `readUInt32LE_append_*` lemmas, and the standard
   pattern for gzip/zlib framing proofs.

3. **lean-fuel-induction** (+46 lines): Added two subsections to the existing
   combined invariant pattern:
   - Threading invariants through long call chains (`.trans` composition of
     data equality, passing updated state through recursion)
   - Deeply nested multi-path case splits (literal vs end-of-block vs
     length-distance paths)

4. **lean-uint-bitvec** (+24 lines): Expanded `bv_decide` section with:
   - When to reach for `bv_decide` (roundtrip proofs, bit extraction, after
     `generalize`)
   - `bv_decide` vs `decide_cbv` vs `decide` trade-offs for large instances

### Commands reviewed

All 7 commands (feature, review, summarize, meditate, plan, work, reflect)
reviewed for staleness. None needed updates — all are current and accurate.

### Key patterns from progress survey

The survey revealed these recurring patterns now captured in skills:
- Do-notation desugaring loops when using `simp only [F, bind, Except.bind]`
  (6+ sessions hit this)
- BitReader invariant threading through 5+ sequential operations (4+ sessions)
- ByteArray three-part concatenation indexing (multiple sessions independently
  derived the same chain)
- `decide_cbv` failures on large arrays (workaround: `decide` with high
  `maxHeartbeats`)

## Decisions

- Added patterns to existing skills rather than creating new ones (all 4 gaps
  fit naturally into existing skill boundaries)
- Kept all examples concrete — copied actual tactic sequences from
  GzipCorrect.lean, BinaryCorrect.lean, and DeflateStoredCorrect.lean

## What remains

- No code changes were made (skills/commands only, as specified)
- Future meditate sessions could address: `▸` vs `rw`+`exact` trade-offs for
  dependent types (partially covered in lean-dependent-types but could use
  more examples from recent UInt8/BitVec work)
