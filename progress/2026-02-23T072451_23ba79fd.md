# Progress: Prove encodeStored_decode roundtrip theorem

**Date**: 2026-02-23T07:24 UTC
**Session**: worker (issue #24)
**Branch**: agent/23ba79fd

## Accomplished

Proved the `encodeStored_decode` roundtrip theorem: encoding data as DEFLATE
stored blocks and then decoding with the spec decoder recovers the original data.

### Changes to `Zip/Spec/Deflate.lean`

1. **Fixed `encodeStored`**: Added 5 padding bits (`List.replicate 5 false`) after
   the 3-bit header (BFINAL + BTYPE) to achieve byte alignment. The DEFLATE spec
   requires stored blocks to be byte-aligned before LEN/NLEN fields.

2. **Simplified `encodeLEU16`**: Changed from manual bit extraction to
   `List.ofFn fun (i : Fin 16) => v.testBit i.val` for cleaner proofs.

3. **Added helper lemmas**:
   - `mod_two_mul`: `v % (2*m) = v % 2 + 2 * ((v/2) % m)` — needed for
     inductive step of readBitsLSB_ofFn_testBit
   - `testBit_zero_eq_mod_two`: bridges testBit 0 and mod 2
   - `readBitsLSB_ofFn_testBit`: reading n bits from testBit encoding yields `v % 2^n`
   - `readBitsLSB_byteToBitsSpec`: reading 8 bits from byteToBitsSpec recovers byte
   - `readNBytes_byteToBitsSpec`: readNBytes on flatMap byteToBitsSpec recovers data
   - `flatMap_byteToBitsSpec_length`: `(data.flatMap byteToBitsSpec).length = 8 * data.length`
   - `encodeStored_length_mod8`: encodeStored output is always byte-aligned
   - `decodeStored_encodeStoredBlock`: decodeStored on padded+encoded block recovers data

4. **Proved `encodeStored_go`** (generalized with accumulator) using
   `encodeStored.induct` for functional induction matching the recursion structure.
   Two cases: single block (BFINAL=1, ≤65535 bytes) and multi-block (BFINAL=0).

5. **Proved `encodeStored_decode`**: wraps encodeStored_go with empty accumulator.

### Key proof patterns discovered

- **List.append associativity**: `++` is left-associative in Lean, so `a ++ b ++ c`
  is `(a ++ b) ++ c`. Lemmas like `readBitsLSB_ofFn_testBit` expect right-associated
  form `a ++ (b ++ c)`. Use `simp only [List.append_assoc]` to right-associate before
  rewriting.

- **XOR bound for omega**: `omega` cannot reason about `Nat.xor`. To prove
  `data.length ^^^ 0xFFFF < 2^16`, use `Nat.xor_lt_two_pow (by omega) (by omega)`.

- **Cons-ified forms after `simp [readBitsLSB]`**: Full `simp` expands
  `List.replicate 5 false` to `false :: false :: ... :: []`. Use `show` to convert
  the goal back to the `List.replicate` form needed by helper lemmas.

- **`Nat.mul_add_mod_of_lt` needs explicit mod bounds**: When the remainder involves
  `(v/2) % m`, omega can't prove it's less than `2*m`. Provide
  `Nat.mod_lt (v/2) hm` and `Nat.mod_lt v ...` explicitly.

## Sorry count

- Start: 4 (3 fuel independence stubs from #21 + 1 encodeStored_decode)
- End: 3 (3 fuel independence stubs from #21)
- Delta: -1

## What remains

- The 3 remaining `sorry`s are fuel independence theorem stubs from issue #21
- Test executable doesn't link due to missing zstd library (pre-existing, needs nix-shell)
