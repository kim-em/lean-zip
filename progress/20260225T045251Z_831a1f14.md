# Progress: 2026-02-25T04:52Z — Feature session (831a1f14)

**Issue**: #248 — Prove gzip_decompressSingle_compress roundtrip theorem
**Type**: implementation (Phase 4+ — gzip framing roundtrip proof)
**Branch**: agent/831a1f14
**Status**: partial completion

## Accomplished

### Proof structure for `gzip_decompressSingle_compress`
- Added `inflate_to_spec_decode`: extracts spec decode fact from `inflate_deflateRaw`
- Added `GzipEncode.compress_eq`: decomposes compress output into header ++ deflated ++ trailer
- Built the full spec decode chain:
  - `inflate_deflateRaw` → `inflate_to_spec_decode` → `hspec_go` (spec decode on deflated)
  - `decode_go_suffix` → `hspec_compressed` (spec decode ignores trailer bits)
  - `inflateRaw_complete` → `hinflRaw` (native inflateRaw succeeds at offset 10)
- Proved header guard conditions: magic bytes (0x1f, 0x8b), compression method (8), flags (0)
- Closed the final `simp` chain that assembles all steps through the Except monad

### What the proof looks like
The theorem statement and all intermediate steps are proved EXCEPT three sorry's that all reduce
to the same root cause. The `simp` chain that assembles `decompressSingle` works end-to-end
when given the three hypotheses.

## NOT completed — 3 sorry's remain

All three sorry's are blocked on the same missing infrastructure:

1. **`hendPos_tight`**: `endPos + 8 ≤ compressed.size` — tight endPos bound
2. **`hcrc`**: CRC32 trailer bytes at endPos match `crc32 0 data`
3. **`hsize_match`**: size trailer bytes at endPos+4 match `data.size.toUInt32`

### Root cause: native-level suffix invariance for `inflateLoop`

The endPos returned by `inflateRaw (header ++ deflated ++ trailer) 10 maxOut` is existentially
quantified by `inflateRaw_complete`. We need `endPos = 10 + deflated.size`, but we only have
`endPos ≤ compressed.size = 18 + deflated.size` (from `inflateRaw_endPos_le`).

The tight bound requires proving that inflateLoop doesn't read into the trailer bytes. This
is the same blocker affecting the 2 sorry's in `ZlibCorrect.lean`.

### Approaches investigated but not sufficient

1. **`inflateRaw_endPos_le`**: gives `endPos ≤ data.size`, not tight enough (off by trailer size)
2. **Spec-level suffix invariance**: `decode_go_suffix` proves the spec ignores trailing bits,
   but doesn't constrain the native endPos
3. **`inflate_correct` + `inflateRaw_complete`**: both directions are available but neither
   constrains endPos tightly — correctness gives spec fuel, completeness gives existential endPos
4. **Applying `inflateRaw_complete` to `header ++ deflated` (without trailer)**: gives tight
   endPos bound on the shorter data, but relating it to `inflateRaw compressed 10 maxOut`
   still requires native suffix invariance

### Recommended next step

Prove `inflateRaw_append_suffix`: if `inflateRaw data startPos maxOut = .ok (result, endPos)`,
then `inflateRaw (data ++ suffix) startPos maxOut = .ok (result, endPos)`. This follows from
the fact that the BitReader only accesses bytes within `data` (since inflateRaw succeeded),
and `(data ++ suffix)[i] = data[i]` when `i < data.size`. This theorem would resolve
all 5 sorry's (3 gzip + 2 zlib) in the codebase.

## Sorry count

- Start: 3 total (1 GzipCorrect, 2 ZlibCorrect)
- End: 5 total (3 GzipCorrect, 2 ZlibCorrect)
- Net: +2 (but the 3 new sorry's are precisely scoped; the 1 original was the entire theorem)

## Decisions

- Followed the zlib proof pattern from `ZlibCorrect.lean` closely
- Used `inflateRaw_complete` (completeness direction) to get the inflateRaw success
- Chose to structure 3 separate sorry's rather than 1 combined sorry to make each
  missing piece explicit and independently provable
