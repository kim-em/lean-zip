# Progress: Fix computeCodeLengths Kraft inequality

**Date**: 2026-02-23T11:48 UTC
**Session**: 59e627e6 (worker)
**Issue**: #92

## What was accomplished

Eliminated the sorry in `computeCodeLengths_valid` by fixing the
`computeCodeLengths` implementation to handle depth-capping overflow.

### Problem

The naive depth capping (`min d maxBits`) in `computeCodeLengths` could
produce oversubscribed code lengths. Verified counterexample:
`computeCodeLengths [(0,100),(1,10),(2,1),(3,1)] 4 2` produced `[1,2,2,2]`
with Kraft sum 5 > 4 = 2^2. The theorem `computeCodeLengths_valid` was
false as stated.

### Solution

Added `fixKraftList`: after capping depths at `maxBits`, check if the
Kraft sum exceeds `2^maxBits`. If so, set all non-zero code lengths to
`maxBits` as a fallback. This produces valid (though potentially
suboptimal) codes. The counterexample now produces `[2,2,2,2]` with
Kraft sum 4 ≤ 4.

Added precondition `n ≤ 2^maxBits` to `computeCodeLengths_valid`. This
is necessary because you can't encode more than `2^maxBits` distinct
symbols with codes of at most `maxBits` bits. For DEFLATE (maxBits=15,
n ≤ 286), this holds trivially since 2^15 = 32768 >> 286.

### Key design decisions

- **Simplest correct approach**: Instead of iterative shortening (which
  requires a termination proof and loop invariant), the fallback simply
  sets all non-zero codes to `maxBits`. The Kraft sum then equals the
  count of non-zero entries, which is bounded by `n ≤ 2^maxBits`.

- **Precondition `n ≤ 2^maxBits`** rather than counting non-zero-frequency
  symbols. This avoids needing to prove that buildHuffmanTree preserves
  leaf count. Slightly stronger than necessary, but trivially satisfied
  for all DEFLATE usage.

- **`kraftSum` moved earlier** in the file (before `computeCodeLengths`)
  since `fixKraftList` depends on it.

### New definitions and lemmas

- `kraftSum` (moved from later in file)
- `fixKraftList` — Kraft inequality fixup
- `fixKraftList_length` — preserves list length
- `fixKraftList_bounded` — preserves ≤ maxBits bound
- `fixKraftList_kraft` — key theorem: kraft sum ≤ 2^maxBits when n ≤ 2^maxBits
- `kraftSum_self` — when all entries equal D, kraftSum = length
- `filter_map_eq_maxBits` — fallback map produces only maxBits values

## Verification

- `lake build` passes (no sorry warnings from HuffmanEncode.lean)
- `lake exe test` passes (all tests)
- Sorry count: 12 → 11 (1 eliminated in HuffmanEncode.lean)
- File size: 354 → 414 lines (well under 500 limit)
- Counterexample verified: `[2, 2, 2, 2]` with kraftSum 4 ≤ 4

## What remains

- 11 sorries remain in other files (DeflateFixedCorrect: 5, DeflateStoredCorrect: 5, DeflateEncode: 1)
- Future improvement: could implement iterative shortening for better code quality (the current fallback produces maximally long codes), but this doesn't matter for correctness
