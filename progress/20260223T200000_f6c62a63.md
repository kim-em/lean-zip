# Progress: Review Native DEFLATE compressor code quality

- **Date**: 2026-02-23T20:00:00Z
- **Session**: worker (review)
- **Issue**: #36

## Accomplished

Reviewed `Zip/Native/BitWriter.lean` (56 lines) and
`Zip/Native/Deflate.lean` (233 lines) for code quality, Lean idioms,
runtime bounds safety, and duplication.

### BitWriter.lean — findings (no changes needed)

- **Bit-packing duplication**: `writeBits.go` and `writeHuffCode.go`
  share the same OR-into-buffer/flush pattern, but each is only ~8 lines.
  Extracting a shared helper would add indirection without real benefit.
- **bitCount safety**: Verified `bitCount` stays in 0–7 range. The
  `≥ 8` check flushes and resets; the increment path stays below 8.
- **writeBits n > 25**: Doc says `n ≤ 25` but no enforcement. For
  `25 < n ≤ 32` the function is still correct (bits above n expected
  to be zero). For `n > 32`, UInt32 shift wraps mod 32, producing
  incorrect bits — but no caller passes n > 13. Doc comment is
  sufficient.
- **Huffman bit order**: Confirmed MSB-first matches RFC 1951 §3.1.1
  and is consistent with the decoder's expectations.

### Deflate.lean — changes made

1. **Extracted `findTableCode`**: `findLengthCode` and `findDistCode`
   were structurally identical (same linear scan, different tables).
   Extracted a shared `findTableCode` parameterized by base/extra
   arrays. Net -6 lines.

2. **Documented `canonicalCodes` assumption**: Added note that non-zero
   code lengths must be ≤ `maxBits` (otherwise `nextCode[len.toNat]!`
   would panic). Valid DEFLATE data satisfies this, but the function
   doesn't enforce it.

3. **Documented unreachable branches in `emitTokens`**: The `| none =>`
   fallbacks for `findLengthCode`/`findDistCode` are unreachable because
   `lz77Greedy` guarantees length 3–258 and distance 1–32768. Replaced
   terse "skip invalid" comments with explanatory comments.

### Runtime bounds (`!`) audit

All `!` accesses in both files are safe at runtime:

- **hashTable/hashValid**: indexed by `h = ... % hashSize`, arrays are
  `.replicate hashSize`. Bound provable but requires carrying proof
  through mutable `while` loop state — not practical without Lake
  `while h :` support.
- **data[pos]!** in `lz77Greedy`: guarded by `while pos + 2 < data.size`
  or `while pos < data.size`. Safe.
- **data[p1+i]!/data[p2+i]!** in `countMatch`: `p2 + i < data.size`
  follows from `maxLen ≤ data.size - pos`; `p1 + i < data.size` follows
  from `p1 < pos` and `i < maxLen ≤ data.size - pos`. Safe.
- **fixedLitCodes[b.toNat]!**: `b : UInt8` so `b.toNat < 256 < 288`.
- **fixedLitCodes[idx + 257]!**: `idx` from `findLengthCode` is 0–28,
  so `idx + 257 ≤ 285 < 288`. Safe.
- **fixedDistCodes[dIdx]!**: `dIdx` from `findDistCode` is 0–29,
  `fixedDistCodes` has 32 entries. Safe.
- **hash3 data[pos/+1/+2]!**: called only when `pos + 2 < data.size`.

None of these are practical to convert to proven bounds in the current
imperative loop structure without significant refactoring.

## Sorry delta

- Start: 6 sorries (all in Zip/Spec/Deflate.lean)
- End: 6 sorries (unchanged)

## What remains

- `Zip/Spec/Deflate.lean` is 1139 lines — splitting into
  `Zip/Spec/DeflateEncode.lean` would be worthwhile in a future session
- The `LZ77Token` (native) vs `LZ77Symbol` (spec) type relationship
  could be documented with a conversion function, but they intentionally
  live in separate layers
