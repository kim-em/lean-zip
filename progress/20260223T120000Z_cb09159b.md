# Progress: 2026-02-23T12:00:00Z — Worker session (cb09159b)

## Issue
#16 — Prove fuel independence theorems

## What was accomplished
- Proved `decodeSymbols_fuel_independent` using induction on fuel with
  `conv` arithmetic trick (`n + 1 + k = (n + k) + 1`) to align `unfold`
  at both `h` and `⊢`
- Proved `decodeCLSymbols_fuel_independent` — required refactoring
  `decodeCLSymbols` to move `if acc.length ≥ totalCodes` outside the
  `do` block (was `do { if ... then return ...; rest }` which creates
  `have __do_jp` join points in desugared form, making `h` and `⊢`
  syntactically different after `unfold`). Used `rw [if_pos/if_neg]`
  for `if` reductions and `by_cases` + `simp [guard, ↓reduceIte]`
  for guard handling.
- Proved `decode_go_fuel_independent` and `decode_fuel_independent`
  using the same pattern. Required `maxRecDepth 4096` due to the large
  term size from `match btype with | 0 | 1 | 2 | _+3`.

## Key proof patterns
- **Fuel arithmetic for `unfold`**: `conv => lhs; rw [show n+1+k = (n+k)+1 from by omega]`
  before `unfold f at h ⊢` ensures both sides unfold at the same successor level.
- **`rw [if_pos/if_neg]` over `simp` for `if` reduction**: `simp [cond] at h`
  over-simplifies (strips `some`/`pure` wrappers). `rw [if_pos hcond] at h`
  only reduces the `if`, preserving the surrounding structure.
- **`by_cases` for guards**: `guard (p)` in `do` blocks uses `Alternative.guard`,
  NOT `Option.guard`. Use `by_cases` on the condition, then
  `simp only [guard, hcond, ↓reduceIte]` to reduce.
- **Avoid `do { if ... then return ...; rest }`**: Creates `have __do_jp` join
  points. Use `if ... then some (...) else do { rest }` instead.

## Sorry count
- Before: 4 (3 fuel independence + 1 encodeStored_decode)
- After: 1 (encodeStored_decode, issue #24)
- Delta: -3

## Build status
- `lake build` passes for all Lean files (106/106)
- Test executable linker fails (pre-existing zstd library issue, not related)
