# 2026-02-23: Implementation — prove inflateLoop_correct and inflate_correct

**Session type**: Implementation
**Starting commit**: `ac2d90c` | **Sorry count**: 1 → 2 (net +1, but different)
**Commits**: `f9b8e7c`, `0dbfbb4`

### Accomplished

Proved the main `inflate_correct` theorem connecting the native pure-Lean
DEFLATE decompressor to the formal specification. This was the primary
remaining goal from Phase 3.

**Structural changes to Inflate.lean**:
- Extracted `inflateLoop` as explicit recursion from `inflateRaw`'s `for` loop
  (`forIn` on `Range` cannot be unfolded for proofs)
- Changed `fixedLitLengths` from `Id.run do` to `Array.replicate++` form
  (enables kernel reduction for spec-side evaluation)
- Made `fixedLitLengths`, `fixedDistLengths`, `decodeDynamicTrees` public
  (needed by InflateCorrect.lean)

**Proof fixes in InflateCorrect.lean**:
- Fixed `decodeHuffman_correct`: changed `∃ specFuel` to native fuel
  (root cause: spec's `decode.go` calls `decodeSymbols` with default fuel
  10000000; simp can't unify with an existential)
- Added `↓reduceIte` to spec-side simp calls (needed to reduce
  `if True/false = true then ...` after `bfinal` condition evaluation)
- Added `← UInt32.toNat_inj` to bridge UInt32 equality to Nat equality
  for `bfinal ≠ 1` contradiction

**New lemmas**:
- `readBit_pos_inv`: `readBit` preserves `bitOff = 0 ∨ pos < data.size`
- `readBits_go_pos_inv`, `readBits_pos_inv`: same for `readBits`
- `decode_go_pos_inv`, `decode_pos_inv`: same for `HuffTree.decode`
- Extended `decodeHuffman_correct` conclusion with position invariant

### Sorry count change explanation

Sorry count went from 1 (`inflate_correct`) to 2 (both in
`decodeDynamicTrees_correct`). The main theorem `inflate_correct` is now
fully proved, but it depends on `decodeDynamicTrees_correct` which has a
sorry. The net sorry count increased by 1 because the single
`inflate_correct` sorry was replaced by 2 sorries in the dynamic tree
sub-lemma (which was always implicitly sorry'd through `inflate_correct`).

### Key proof techniques

- **`by_cases + subst` for UInt32 match**: `split at h` doesn't substitute
  the discriminant in other hypotheses; `by_cases hbt0 : btype = 0; subst hbt0`
  does, letting `(0 : UInt32).toNat` reduce definitionally
- **UInt32/Nat BEq bridge**: `← UInt32.toNat_inj` in `simp_all` rewrites
  `¬(bfinal = 1)` (UInt32) to `¬(bfinal.toNat = 1)` (Nat)
- **`show ... = false from by cases h : ... <;> simp_all`**: proves
  `(bfinal.toNat == 1) = false` inline for simp reduction

### Remaining

- `decodeDynamicTrees_correct` (2 sorries): dynamic Huffman tree correspondence
